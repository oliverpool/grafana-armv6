{"version":3,"file":"5135.8ae3329e034d31b55214.js","mappings":"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","sources":["webpack://grafana/./.yarn/__virtual__/@grafana-data-virtual-adf1e43f85/1/packages/grafana-data/src/field/fieldComparers.ts","webpack://grafana/./.yarn/__virtual__/@grafana-data-virtual-adf1e43f85/1/packages/grafana-data/src/transformations/matchers/fieldTypeMatcher.ts","webpack://grafana/./.yarn/__virtual__/@grafana-data-virtual-adf1e43f85/1/packages/grafana-data/src/transformations/matchers/ids.ts","webpack://grafana/./.yarn/__virtual__/@grafana-data-virtual-adf1e43f85/1/packages/grafana-data/src/transformations/matchers/refIdMatcher.ts","webpack://grafana/./.yarn/__virtual__/@grafana-data-virtual-adf1e43f85/1/packages/grafana-data/src/transformations/matchers/simpleFieldMatcher.ts","webpack://grafana/./.yarn/__virtual__/@grafana-data-virtual-adf1e43f85/1/packages/grafana-data/src/transformations/matchers/valueMatchers/equalMatchers.ts","webpack://grafana/./.yarn/__virtual__/@grafana-data-virtual-adf1e43f85/1/packages/grafana-data/src/transformations/matchers/valueMatchers/nullMatchers.ts","webpack://grafana/./.yarn/__virtual__/@grafana-data-virtual-adf1e43f85/1/packages/grafana-data/src/transformations/matchers/valueMatchers/numericMatchers.ts","webpack://grafana/./.yarn/__virtual__/@grafana-data-virtual-adf1e43f85/1/packages/grafana-data/src/transformations/matchers/valueMatchers/rangeMatchers.ts","webpack://grafana/./.yarn/__virtual__/@grafana-data-virtual-adf1e43f85/1/packages/grafana-data/src/transformations/matchers/valueMatchers/regexMatchers.ts","webpack://grafana/./.yarn/__virtual__/@grafana-data-virtual-adf1e43f85/1/packages/grafana-data/src/transformations/transformers/ids.ts","webpack://grafana/./.yarn/__virtual__/@grafana-data-virtual-adf1e43f85/1/packages/grafana-data/src/utils/Registry.ts","webpack://grafana/./.yarn/__virtual__/@grafana-data-virtual-adf1e43f85/1/packages/grafana-data/src/vector/ArrayVector.ts","webpack://grafana/./.yarn/__virtual__/@grafana-data-virtual-adf1e43f85/1/packages/grafana-data/src/vector/SortedVector.ts","webpack://grafana/./.yarn/__virtual__/@grafana-data-virtual-adf1e43f85/1/packages/grafana-data/src/vector/vectorToArray.ts","webpack://grafana/./.yarn/__virtual__/@grafana-runtime-virtual-f9d61a496b/1/packages/grafana-runtime/src/utils/toDataQueryError.ts","webpack://grafana/./public/app/features/live/centrifuge/LiveDataStream.ts","webpack://grafana/./public/app/features/live/centrifuge/channel.ts","webpack://grafana/./public/app/features/live/centrifuge/service.ts","webpack://grafana/./public/app/features/live/centrifuge/transferHandlers.ts","webpack://grafana/./public/app/plugins/datasource/prometheus/legend.ts"],"sourcesContent":["import { isNumber } from 'lodash';\n\nimport { dateTime, isDateTime } from '../datetime';\nimport { Field, FieldType } from '../types/dataFrame';\nimport { Vector } from '../types/vector';\n\ntype IndexComparer = (a: number, b: number) => number;\n\n/** @public */\nexport const fieldIndexComparer = (field: Field, reverse = false): IndexComparer => {\n  const values = field.values;\n\n  switch (field.type) {\n    case FieldType.number:\n      return numericIndexComparer(values, reverse);\n    case FieldType.string:\n      return stringIndexComparer(values, reverse);\n    case FieldType.boolean:\n      return booleanIndexComparer(values, reverse);\n    case FieldType.time:\n      return timeIndexComparer(values, reverse);\n    default:\n      return naturalIndexComparer(reverse);\n  }\n};\n\n/** @public */\nexport const timeComparer = (a: unknown, b: unknown): number => {\n  if (!a || !b) {\n    return falsyComparer(a, b);\n  }\n\n  if (isNumber(a) && isNumber(b)) {\n    return numericComparer(a, b);\n  }\n\n  if (isDateTime(a) && isDateTime(b)) {\n    if (dateTime(a).isBefore(b)) {\n      return -1;\n    }\n\n    if (dateTime(b).isBefore(a)) {\n      return 1;\n    }\n  }\n\n  return 0;\n};\n\n/** @public */\nexport const numericComparer = (a: number, b: number): number => {\n  return a - b;\n};\n\n/** @public */\nexport const stringComparer = (a: string, b: string): number => {\n  if (!a || !b) {\n    return falsyComparer(a, b);\n  }\n  return a.localeCompare(b);\n};\n\nexport const booleanComparer = (a: boolean, b: boolean): number => {\n  return falsyComparer(a, b);\n};\n\nconst falsyComparer = (a: unknown, b: unknown): number => {\n  if (!a && b) {\n    return 1;\n  }\n\n  if (a && !b) {\n    return -1;\n  }\n\n  return 0;\n};\n\nconst timeIndexComparer = (values: Vector<unknown>, reverse: boolean): IndexComparer => {\n  return (a: number, b: number): number => {\n    const vA = values.get(a);\n    const vB = values.get(b);\n    return reverse ? timeComparer(vB, vA) : timeComparer(vA, vB);\n  };\n};\n\nconst booleanIndexComparer = (values: Vector<boolean>, reverse: boolean): IndexComparer => {\n  return (a: number, b: number): number => {\n    const vA = values.get(a);\n    const vB = values.get(b);\n    return reverse ? booleanComparer(vB, vA) : booleanComparer(vA, vB);\n  };\n};\n\nconst numericIndexComparer = (values: Vector<number>, reverse: boolean): IndexComparer => {\n  return (a: number, b: number): number => {\n    const vA = values.get(a);\n    const vB = values.get(b);\n    return reverse ? numericComparer(vB, vA) : numericComparer(vA, vB);\n  };\n};\n\nconst stringIndexComparer = (values: Vector<string>, reverse: boolean): IndexComparer => {\n  return (a: number, b: number): number => {\n    const vA = values.get(a);\n    const vB = values.get(b);\n    return reverse ? stringComparer(vB, vA) : stringComparer(vA, vB);\n  };\n};\n\nconst naturalIndexComparer = (reverse: boolean): IndexComparer => {\n  return (a: number, b: number): number => {\n    return reverse ? numericComparer(b, a) : numericComparer(a, b);\n  };\n};\n","import { Field, FieldType, DataFrame } from '../../types/dataFrame';\nimport { FieldMatcherInfo } from '../../types/transformations';\n\nimport { FieldMatcherID } from './ids';\n\n// General Field matcher\nconst fieldTypeMatcher: FieldMatcherInfo<FieldType> = {\n  id: FieldMatcherID.byType,\n  name: 'Field Type',\n  description: 'match based on the field type',\n  defaultOptions: FieldType.number,\n\n  get: (type: FieldType) => {\n    return (field: Field, frame: DataFrame, allFrames: DataFrame[]) => {\n      return type === field.type;\n    };\n  },\n\n  getOptionsDisplayText: (type: FieldType) => {\n    return `Field type: ${type}`;\n  },\n};\n\n// Numeric Field matcher\n// This gets its own entry so it shows up in the dropdown\nconst numericMatcher: FieldMatcherInfo = {\n  id: FieldMatcherID.numeric,\n  name: 'Numeric Fields',\n  description: 'Fields with type number',\n\n  get: () => {\n    return fieldTypeMatcher.get(FieldType.number);\n  },\n\n  getOptionsDisplayText: () => {\n    return 'Numeric Fields';\n  },\n};\n\n// Time Field matcher\nconst timeMatcher: FieldMatcherInfo = {\n  id: FieldMatcherID.time,\n  name: 'Time Fields',\n  description: 'Fields with type time',\n\n  get: () => {\n    return fieldTypeMatcher.get(FieldType.time);\n  },\n\n  getOptionsDisplayText: () => {\n    return 'Time Fields';\n  },\n};\n\n/**\n * Registry Initialization\n */\nexport function getFieldTypeMatchers(): FieldMatcherInfo[] {\n  return [fieldTypeMatcher, numericMatcher, timeMatcher];\n}\n","// This needs to be in its own file to avoid circular references\n\n// Builtin Predicates\n// not using 'any' and 'never' since they are reserved keywords\nexport enum MatcherID {\n  anyMatch = 'anyMatch', // checks children\n  allMatch = 'allMatch', // checks children\n  invertMatch = 'invertMatch', // checks child\n  alwaysMatch = 'alwaysMatch',\n  neverMatch = 'neverMatch',\n}\n\nexport enum FieldMatcherID {\n  // Specific Types\n  numeric = 'numeric',\n  time = 'time', // Can be multiple times\n  first = 'first',\n  firstTimeField = 'firstTimeField', // Only the first fime field\n\n  // With arguments\n  byType = 'byType',\n  byName = 'byName',\n  byNames = 'byNames',\n  byRegexp = 'byRegexp',\n  byRegexpOrNames = 'byRegexpOrNames',\n  byFrameRefID = 'byFrameRefID',\n  // byIndex = 'byIndex',\n  // byLabel = 'byLabel',\n}\n\n/**\n * Field name matchers\n */\nexport enum FrameMatcherID {\n  byName = 'byName',\n  byRefId = 'byRefId',\n  byIndex = 'byIndex',\n  byLabel = 'byLabel',\n}\n\n/**\n * @public\n */\nexport enum ValueMatcherID {\n  regex = 'regex',\n  isNull = 'isNull',\n  isNotNull = 'isNotNull',\n  greater = 'greater',\n  greaterOrEqual = 'greaterOrEqual',\n  lower = 'lower',\n  lowerOrEqual = 'lowerOrEqual',\n  equal = 'equal',\n  notEqual = 'notEqual',\n  between = 'between',\n}\n","import { stringToJsRegex } from '../../text';\nimport { DataFrame } from '../../types/dataFrame';\nimport { FrameMatcherInfo } from '../../types/transformations';\n\nimport { FrameMatcherID } from './ids';\n\n// General Field matcher\nconst refIdMacher: FrameMatcherInfo<string> = {\n  id: FrameMatcherID.byRefId,\n  name: 'Query refId',\n  description: 'match the refId',\n  defaultOptions: 'A',\n\n  get: (pattern: string) => {\n    const regex = stringToJsRegex(pattern);\n    return (frame: DataFrame) => {\n      return regex.test(frame.refId || '');\n    };\n  },\n\n  getOptionsDisplayText: (pattern: string) => {\n    return `RefID: ${pattern}`;\n  },\n};\n\nexport function getRefIdMatchers(): FrameMatcherInfo[] {\n  return [refIdMacher];\n}\n","import { Field, FieldType, DataFrame } from '../../types/dataFrame';\nimport { FieldMatcherInfo } from '../../types/transformations';\n\nimport { FieldMatcherID } from './ids';\n\nconst firstFieldMatcher: FieldMatcherInfo = {\n  id: FieldMatcherID.first,\n  name: 'First Field',\n  description: 'The first field in the frame',\n\n  get: (type: FieldType) => {\n    return (field: Field, frame: DataFrame, allFrames: DataFrame[]) => {\n      return field === frame.fields[0];\n    };\n  },\n\n  getOptionsDisplayText: () => {\n    return `First field`;\n  },\n};\n\nconst firstTimeFieldMatcher: FieldMatcherInfo = {\n  id: FieldMatcherID.firstTimeField,\n  name: 'First time field',\n  description: 'The first field of type time in a frame',\n\n  get: (type: FieldType) => {\n    return (field: Field, frame: DataFrame, allFrames: DataFrame[]) => {\n      return field.type === FieldType.time && field === frame.fields.find((f) => f.type === FieldType.time);\n    };\n  },\n\n  getOptionsDisplayText: () => {\n    return `First time field`;\n  },\n};\n\n/**\n * Registry Initialization\n */\nexport function getSimpleFieldMatchers(): FieldMatcherInfo[] {\n  return [firstFieldMatcher, firstTimeFieldMatcher];\n}\n","import { Field } from '../../../types/dataFrame';\nimport { ValueMatcherInfo } from '../../../types/transformations';\nimport { ValueMatcherID } from '../ids';\n\nimport { BasicValueMatcherOptions } from './types';\n\nconst isEqualValueMatcher: ValueMatcherInfo<BasicValueMatcherOptions> = {\n  id: ValueMatcherID.equal,\n  name: 'Is equal',\n  description: 'Match where value for given field is equal to options value.',\n  get: (options) => {\n    return (valueIndex: number, field: Field) => {\n      const value = field.values.get(valueIndex);\n      // eslint-disable-next-line eqeqeq\n      return value == options.value;\n    };\n  },\n  getOptionsDisplayText: () => {\n    return `Matches all rows where field is null.`;\n  },\n  isApplicable: () => true,\n  getDefaultOptions: () => ({ value: '' }),\n};\n\nconst isNotEqualValueMatcher: ValueMatcherInfo<BasicValueMatcherOptions> = {\n  id: ValueMatcherID.notEqual,\n  name: 'Is not equal',\n  description: 'Match where value for given field is not equal to options value.',\n  get: (options) => {\n    return (valueIndex: number, field: Field) => {\n      const value = field.values.get(valueIndex);\n      // eslint-disable-next-line eqeqeq\n      return value != options.value;\n    };\n  },\n  getOptionsDisplayText: () => {\n    return `Matches all rows where field is not null.`;\n  },\n  isApplicable: () => true,\n  getDefaultOptions: () => ({ value: '' }),\n};\n\nexport const getEqualValueMatchers = (): ValueMatcherInfo[] => [isEqualValueMatcher, isNotEqualValueMatcher];\n","import { Field } from '../../../types/dataFrame';\nimport { ValueMatcherInfo } from '../../../types/transformations';\nimport { ValueMatcherID } from '../ids';\n\nimport { ValueMatcherOptions } from './types';\n\nconst isNullValueMatcher: ValueMatcherInfo<ValueMatcherOptions> = {\n  id: ValueMatcherID.isNull,\n  name: 'Is null',\n  description: 'Match where value for given field is null.',\n  get: () => {\n    return (valueIndex: number, field: Field) => {\n      const value = field.values.get(valueIndex);\n      return value == null;\n    };\n  },\n  getOptionsDisplayText: () => {\n    return `Matches all rows where field is null.`;\n  },\n  isApplicable: () => true,\n  getDefaultOptions: () => ({}),\n};\n\nconst isNotNullValueMatcher: ValueMatcherInfo<ValueMatcherOptions> = {\n  id: ValueMatcherID.isNotNull,\n  name: 'Is not null',\n  description: 'Match where value for given field is not null.',\n  get: () => {\n    return (valueIndex: number, field: Field) => {\n      const value = field.values.get(valueIndex);\n      return value != null;\n    };\n  },\n  getOptionsDisplayText: () => {\n    return `Matches all rows where field is not null.`;\n  },\n  isApplicable: () => true,\n  getDefaultOptions: () => ({}),\n};\n\nexport const getNullValueMatchers = (): ValueMatcherInfo[] => [isNullValueMatcher, isNotNullValueMatcher];\n","import { Field, FieldType } from '../../../types/dataFrame';\nimport { ValueMatcherInfo } from '../../../types/transformations';\nimport { ValueMatcherID } from '../ids';\n\nimport { BasicValueMatcherOptions } from './types';\n\nconst isGreaterValueMatcher: ValueMatcherInfo<BasicValueMatcherOptions<number>> = {\n  id: ValueMatcherID.greater,\n  name: 'Is greater',\n  description: 'Match when field value is greater than option.',\n  get: (options) => {\n    return (valueIndex: number, field: Field) => {\n      const value = field.values.get(valueIndex);\n      if (isNaN(value)) {\n        return false;\n      }\n      return value > options.value;\n    };\n  },\n  getOptionsDisplayText: (options) => {\n    return `Matches all rows where field value is greater than: ${options.value}.`;\n  },\n  isApplicable: (field) => field.type === FieldType.number,\n  getDefaultOptions: () => ({ value: 0 }),\n};\n\nconst isGreaterOrEqualValueMatcher: ValueMatcherInfo<BasicValueMatcherOptions<number>> = {\n  id: ValueMatcherID.greaterOrEqual,\n  name: 'Is greater or equal',\n  description: 'Match when field value is greater than or equal to option.',\n  get: (options) => {\n    return (valueIndex: number, field: Field) => {\n      const value = field.values.get(valueIndex);\n      if (isNaN(value)) {\n        return false;\n      }\n      return value >= options.value;\n    };\n  },\n  getOptionsDisplayText: (options) => {\n    return `Matches all rows where field value is greater than or equal to: ${options.value}.`;\n  },\n  isApplicable: (field) => field.type === FieldType.number,\n  getDefaultOptions: () => ({ value: 0 }),\n};\n\nconst isLowerValueMatcher: ValueMatcherInfo<BasicValueMatcherOptions<number>> = {\n  id: ValueMatcherID.lower,\n  name: 'Is lower',\n  description: 'Match when field value is lower than option.',\n  get: (options) => {\n    return (valueIndex: number, field: Field) => {\n      const value = field.values.get(valueIndex);\n      if (isNaN(value)) {\n        return false;\n      }\n      return value < options.value;\n    };\n  },\n  getOptionsDisplayText: (options) => {\n    return `Matches all rows where field value is lower than: ${options.value}.`;\n  },\n  isApplicable: (field) => field.type === FieldType.number,\n  getDefaultOptions: () => ({ value: 0 }),\n};\n\nconst isLowerOrEqualValueMatcher: ValueMatcherInfo<BasicValueMatcherOptions<number>> = {\n  id: ValueMatcherID.lowerOrEqual,\n  name: 'Is lower or equal',\n  description: 'Match when field value is lower or equal than option.',\n  get: (options) => {\n    return (valueIndex: number, field: Field) => {\n      const value = field.values.get(valueIndex);\n      if (isNaN(value)) {\n        return false;\n      }\n      return value <= options.value;\n    };\n  },\n  getOptionsDisplayText: (options) => {\n    return `Matches all rows where field value is lower or equal than: ${options.value}.`;\n  },\n  isApplicable: (field) => field.type === FieldType.number,\n  getDefaultOptions: () => ({ value: 0 }),\n};\n\nexport const getNumericValueMatchers = (): ValueMatcherInfo[] => [\n  isGreaterValueMatcher,\n  isGreaterOrEqualValueMatcher,\n  isLowerValueMatcher,\n  isLowerOrEqualValueMatcher,\n];\n","import { Field, FieldType } from '../../../types/dataFrame';\nimport { ValueMatcherInfo } from '../../../types/transformations';\nimport { ValueMatcherID } from '../ids';\n\nimport { RangeValueMatcherOptions } from './types';\n\nconst isBetweenValueMatcher: ValueMatcherInfo<RangeValueMatcherOptions<number>> = {\n  id: ValueMatcherID.between,\n  name: 'Is between',\n  description: 'Match when field value is between given option values.',\n  get: (options) => {\n    return (valueIndex: number, field: Field) => {\n      const value = field.values.get(valueIndex);\n      if (isNaN(value)) {\n        return false;\n      }\n      return value > options.from && value < options.to;\n    };\n  },\n  getOptionsDisplayText: (options) => {\n    return `Matches all rows where field value is between ${options.from} and ${options.to}.`;\n  },\n  isApplicable: (field) => field.type === FieldType.number,\n  getDefaultOptions: () => ({ from: 0, to: 100 }),\n};\n\nexport const getRangeValueMatchers = (): ValueMatcherInfo[] => [isBetweenValueMatcher];\n","import { Field } from '../../../types/dataFrame';\nimport { ValueMatcherInfo } from '../../../types/transformations';\nimport { ValueMatcherID } from '../ids';\n\nimport { BasicValueMatcherOptions } from './types';\n\nconst regexValueMatcher: ValueMatcherInfo<BasicValueMatcherOptions<string>> = {\n  id: ValueMatcherID.regex,\n  name: 'Regex',\n  description: 'Match when field value is matching regex.',\n  get: (options) => {\n    const regex = new RegExp(options.value);\n\n    return (valueIndex: number, field: Field) => {\n      const value = field.values.get(valueIndex);\n      return regex.test(value);\n    };\n  },\n  getOptionsDisplayText: (options) => {\n    return `Matches all rows where field value is matching regex: ${options.value}`;\n  },\n  isApplicable: () => true,\n  getDefaultOptions: () => ({ value: '.*' }),\n};\n\nexport const getRegexValueMatcher = (): ValueMatcherInfo[] => [regexValueMatcher];\n","export enum DataTransformerID {\n  append = 'append',\n  //  rotate = 'rotate', // Columns to rows\n  reduce = 'reduce',\n  order = 'order',\n  organize = 'organize',\n  rename = 'rename',\n  calculateField = 'calculateField',\n  /** @deprecated use joinByField */\n  seriesToColumns = 'seriesToColumns',\n  seriesToRows = 'seriesToRows',\n  merge = 'merge',\n  concatenate = 'concatenate',\n  labelsToFields = 'labelsToFields',\n  filterFields = 'filterFields',\n  filterFieldsByName = 'filterFieldsByName',\n  filterFrames = 'filterFrames',\n  filterByRefId = 'filterByRefId',\n  renameByRegex = 'renameByRegex',\n  filterByValue = 'filterByValue',\n  noop = 'noop',\n  ensureColumns = 'ensureColumns',\n  groupBy = 'groupBy',\n  sortBy = 'sortBy',\n  histogram = 'histogram',\n  configFromData = 'configFromData',\n  rowsToFields = 'rowsToFields',\n  prepareTimeSeries = 'prepareTimeSeries',\n  convertFieldType = 'convertFieldType',\n  fieldLookup = 'fieldLookup',\n  heatmap = 'heatmap',\n  spatial = 'spatial',\n  joinByField = 'joinByField',\n  joinByLabels = 'joinByLabels',\n  extractFields = 'extractFields',\n  groupingToMatrix = 'groupingToMatrix',\n  limit = 'limit',\n  partitionByValues = 'partitionByValues',\n}\n","import { PluginState } from '../types';\nimport { SelectableValue } from '../types/select';\n\nexport interface RegistryItem {\n  id: string; // Unique Key -- saved in configs\n  name: string; // Display Name, can change without breaking configs\n  description?: string;\n  aliasIds?: string[]; // when the ID changes, we may want backwards compatibility ('current' => 'last')\n\n  /**\n   * Some extensions should not be user selectable\n   *  like: 'all' and 'any' matchers;\n   */\n  excludeFromPicker?: boolean;\n\n  /**\n   * Optional feature state\n   */\n  state?: PluginState;\n}\n\nexport interface RegistryItemWithOptions<TOptions = any> extends RegistryItem {\n  /**\n   * Convert the options to a string\n   */\n  getOptionsDisplayText?: (options: TOptions) => string;\n\n  /**\n   * Default options used if nothing else is specified\n   */\n  defaultOptions?: TOptions;\n}\n\ninterface RegistrySelectInfo {\n  options: Array<SelectableValue<string>>;\n  current: Array<SelectableValue<string>>;\n}\n\nexport class Registry<T extends RegistryItem> {\n  private ordered: T[] = [];\n  private byId = new Map<string, T>();\n  private initialized = false;\n\n  constructor(private init?: () => T[]) {\n    this.init = init;\n  }\n\n  setInit = (init: () => T[]) => {\n    if (this.initialized) {\n      throw new Error('Registry already initialized');\n    }\n    this.init = init;\n  };\n\n  getIfExists(id: string | undefined): T | undefined {\n    if (!this.initialized) {\n      this.initialize();\n    }\n\n    if (id) {\n      return this.byId.get(id);\n    }\n\n    return undefined;\n  }\n\n  private initialize() {\n    if (this.init) {\n      for (const ext of this.init()) {\n        this.register(ext);\n      }\n    }\n    this.sort();\n    this.initialized = true;\n  }\n\n  get(id: string): T {\n    const v = this.getIfExists(id);\n    if (!v) {\n      throw new Error(`\"${id}\" not found in: ${this.list().map((v) => v.id)}`);\n    }\n    return v;\n  }\n\n  selectOptions(current?: string[], filter?: (ext: T) => boolean): RegistrySelectInfo {\n    if (!this.initialized) {\n      this.initialize();\n    }\n\n    const select = {\n      options: [],\n      current: [],\n    } as RegistrySelectInfo;\n\n    const currentOptions: Record<string, SelectableValue<string>> = {};\n    if (current) {\n      for (const id of current) {\n        currentOptions[id] = {};\n      }\n    }\n\n    for (const ext of this.ordered) {\n      if (ext.excludeFromPicker) {\n        continue;\n      }\n      if (filter && !filter(ext)) {\n        continue;\n      }\n\n      const option = {\n        value: ext.id,\n        label: ext.name,\n        description: ext.description,\n      };\n\n      if (ext.state === PluginState.alpha) {\n        option.label += ' (alpha)';\n      }\n\n      select.options.push(option);\n      if (currentOptions[ext.id]) {\n        currentOptions[ext.id] = option;\n      }\n    }\n\n    if (current) {\n      // this makes sure we preserve the order of ids\n      select.current = Object.values(currentOptions);\n    }\n\n    return select;\n  }\n\n  /**\n   * Return a list of values by ID, or all values if not specified\n   */\n  list(ids?: string[]): T[] {\n    if (!this.initialized) {\n      this.initialize();\n    }\n\n    if (ids) {\n      const found: T[] = [];\n      for (const id of ids) {\n        const v = this.getIfExists(id);\n        if (v) {\n          found.push(v);\n        }\n      }\n      return found;\n    }\n\n    return this.ordered;\n  }\n\n  isEmpty(): boolean {\n    if (!this.initialized) {\n      this.initialize();\n    }\n\n    return this.ordered.length === 0;\n  }\n\n  register(ext: T) {\n    if (this.byId.has(ext.id)) {\n      throw new Error('Duplicate Key:' + ext.id);\n    }\n\n    this.byId.set(ext.id, ext);\n    this.ordered.push(ext);\n\n    if (ext.aliasIds) {\n      for (const alias of ext.aliasIds) {\n        if (!this.byId.has(alias)) {\n          this.byId.set(alias, ext);\n        }\n      }\n    }\n\n    if (this.initialized) {\n      this.sort();\n    }\n  }\n\n  private sort() {\n    // TODO sort the list\n  }\n}\n","import { MutableVector } from '../types/vector';\n\nimport { FunctionalVector } from './FunctionalVector';\n\n/**\n * @public\n */\nexport class ArrayVector<T = any> extends FunctionalVector<T> implements MutableVector<T> {\n  buffer: T[];\n\n  constructor(buffer?: T[]) {\n    super();\n    this.buffer = buffer ? buffer : [];\n  }\n\n  get length() {\n    return this.buffer.length;\n  }\n\n  add(value: T) {\n    this.buffer.push(value);\n  }\n\n  get(index: number): T {\n    return this.buffer[index];\n  }\n\n  set(index: number, value: T) {\n    this.buffer[index] = value;\n  }\n\n  reverse() {\n    this.buffer.reverse();\n  }\n\n  toArray(): T[] {\n    return this.buffer;\n  }\n\n  toJSON(): T[] {\n    return this.buffer;\n  }\n}\n","import { Vector } from '../types/vector';\n\nimport { vectorToArray } from './vectorToArray';\n\n/**\n * Values are returned in the order defined by the input parameter\n */\nexport class SortedVector<T = any> implements Vector<T> {\n  constructor(private source: Vector<T>, private order: number[]) {}\n\n  get length(): number {\n    return this.source.length;\n  }\n\n  get(index: number): T {\n    return this.source.get(this.order[index]);\n  }\n\n  toArray(): T[] {\n    return vectorToArray(this);\n  }\n\n  toJSON(): T[] {\n    return vectorToArray(this);\n  }\n\n  getOrderArray(): number[] {\n    return this.order;\n  }\n}\n","import { Vector } from '../types/vector';\n\nexport function vectorToArray<T>(v: Vector<T>): T[] {\n  const arr: T[] = Array(v.length);\n  for (let i = 0; i < v.length; i++) {\n    arr[i] = v.get(i);\n  }\n  return arr;\n}\n","import { DataQueryError } from '@grafana/data';\n\n/**\n * Convert an object into a DataQueryError -- if this is an HTTP response,\n * it will put the correct values in the error field\n *\n * @public\n */\nexport function toDataQueryError(err: DataQueryError | string | unknown): DataQueryError {\n  const error: DataQueryError = err || {};\n\n  if (!error.message) {\n    if (typeof err === 'string') {\n      return { message: err };\n    }\n\n    let message = 'Query error';\n    if (error.message) {\n      message = error.message;\n    } else if (error.data && error.data.message && error.data?.message !== 'Query data error') {\n      message = error.data.message;\n    } else if (error?.data?.message === 'Query data error' && error?.data?.error) {\n      message = error.data.error;\n    } else if (error.data && error.data.error) {\n      message = error.data.error;\n    } else if (error.status) {\n      message = `Query error: ${error.status} ${error.statusText}`;\n    }\n    error.message = message;\n  }\n\n  return error;\n}\n","import { map, Observable, ReplaySubject, Subject, Subscriber, Subscription } from 'rxjs';\n\nimport {\n  DataFrameJSON,\n  DataQueryError,\n  Field,\n  isLiveChannelMessageEvent,\n  isLiveChannelStatusEvent,\n  LiveChannelConnectionState,\n  LiveChannelEvent,\n  LiveChannelId,\n  LoadingState,\n} from '@grafana/data';\nimport { LiveDataStreamOptions, StreamingFrameAction, StreamingFrameOptions } from '@grafana/runtime/src/services/live';\nimport { toDataQueryError } from '@grafana/runtime/src/utils/toDataQueryError';\n\nimport { getStreamingFrameOptions, StreamingDataFrame } from '../data/StreamingDataFrame';\nimport { StreamingResponseDataType } from '../data/utils';\n\nimport { DataStreamSubscriptionKey, StreamingDataQueryResponse } from './service';\n\nconst bufferIfNot =\n  (canEmitObservable: Observable<boolean>) =>\n  <T>(source: Observable<T>): Observable<T[]> => {\n    return new Observable((subscriber: Subscriber<T[]>) => {\n      let buffer: T[] = [];\n      let canEmit = true;\n\n      const emitBuffer = () => {\n        subscriber.next(buffer);\n        buffer = [];\n      };\n\n      const canEmitSub = canEmitObservable.subscribe({\n        next: (val) => {\n          canEmit = val;\n\n          if (canEmit && buffer.length) {\n            emitBuffer();\n          }\n        },\n      });\n\n      const sourceSub = source.subscribe({\n        next(value) {\n          if (canEmit) {\n            if (!buffer.length) {\n              subscriber.next([value]);\n            } else {\n              emitBuffer();\n            }\n          } else {\n            buffer.push(value);\n          }\n        },\n        error(error) {\n          subscriber.error(error);\n        },\n        complete() {\n          subscriber.complete();\n        },\n      });\n\n      return () => {\n        sourceSub.unsubscribe();\n        canEmitSub.unsubscribe();\n      };\n    });\n  };\n\nexport type DataStreamHandlerDeps<T> = {\n  channelId: LiveChannelId;\n  liveEventsObservable: Observable<LiveChannelEvent<T>>;\n  onShutdown: () => void;\n  subscriberReadiness: Observable<boolean>;\n  defaultStreamingFrameOptions: Readonly<StreamingFrameOptions>;\n  shutdownDelayInMs: number;\n};\n\nenum InternalStreamMessageType {\n  Error,\n  NewValuesSameSchema,\n  ChangedSchema,\n}\n\ntype InternalStreamMessageTypeToData = {\n  [InternalStreamMessageType.Error]: {\n    error: DataQueryError;\n  };\n  [InternalStreamMessageType.ChangedSchema]: {};\n  [InternalStreamMessageType.NewValuesSameSchema]: {\n    values: unknown[][];\n  };\n};\n\ntype InternalStreamMessage<T = InternalStreamMessageType> = T extends InternalStreamMessageType\n  ? {\n      type: T;\n    } & InternalStreamMessageTypeToData[T]\n  : never;\n\nconst reduceNewValuesSameSchemaMessages = (\n  packets: Array<InternalStreamMessage<InternalStreamMessageType.NewValuesSameSchema>>\n) => ({\n  values: packets.reduce((acc, { values }) => {\n    for (let i = 0; i < values.length; i++) {\n      if (!acc[i]) {\n        acc[i] = [];\n      }\n      for (let j = 0; j < values[i].length; j++) {\n        acc[i].push(values[i][j]);\n      }\n    }\n    return acc;\n  }, [] as unknown[][]),\n  type: InternalStreamMessageType.NewValuesSameSchema,\n});\n\nconst filterMessages = <T extends InternalStreamMessageType>(\n  packets: InternalStreamMessage[],\n  type: T\n): Array<InternalStreamMessage<T>> => packets.filter((p) => p.type === type) as Array<InternalStreamMessage<T>>;\n\nexport class LiveDataStream<T = unknown> {\n  private frameBuffer: StreamingDataFrame;\n  private liveEventsSubscription: Subscription;\n  private stream: Subject<InternalStreamMessage> = new ReplaySubject(1);\n  private shutdownTimeoutId: ReturnType<typeof setTimeout> | undefined;\n\n  constructor(private deps: DataStreamHandlerDeps<T>) {\n    this.frameBuffer = StreamingDataFrame.empty(deps.defaultStreamingFrameOptions);\n    this.liveEventsSubscription = deps.liveEventsObservable.subscribe({\n      error: this.onError,\n      complete: this.onComplete,\n      next: this.onNext,\n    });\n  }\n\n  private shutdown = () => {\n    this.stream.complete();\n    this.liveEventsSubscription.unsubscribe();\n    this.deps.onShutdown();\n  };\n\n  private shutdownIfNoSubscribers = () => {\n    if (!this.stream.observed) {\n      this.shutdown();\n    }\n  };\n\n  private onError = (err: any) => {\n    console.log('LiveQuery [error]', { err }, this.deps.channelId);\n    this.stream.next({\n      type: InternalStreamMessageType.Error,\n      error: toDataQueryError(err),\n    });\n    this.shutdown();\n  };\n\n  private onComplete = () => {\n    console.log('LiveQuery [complete]', this.deps.channelId);\n    this.shutdown();\n  };\n\n  private onNext = (evt: LiveChannelEvent) => {\n    if (isLiveChannelMessageEvent(evt)) {\n      this.process(evt.message);\n      return;\n    }\n\n    const liveChannelStatusEvent = isLiveChannelStatusEvent(evt);\n    if (liveChannelStatusEvent && evt.error) {\n      this.stream.next({\n        type: InternalStreamMessageType.Error,\n        error: {\n          ...toDataQueryError(evt.error),\n          message: `Streaming channel error: ${evt.error.message}`,\n        },\n      });\n      return;\n    }\n\n    if (\n      liveChannelStatusEvent &&\n      (evt.state === LiveChannelConnectionState.Connected || evt.state === LiveChannelConnectionState.Pending) &&\n      evt.message\n    ) {\n      this.process(evt.message);\n    }\n  };\n\n  private process = (msg: DataFrameJSON) => {\n    const packetInfo = this.frameBuffer.push(msg);\n\n    if (packetInfo.schemaChanged) {\n      this.stream.next({\n        type: InternalStreamMessageType.ChangedSchema,\n      });\n    } else {\n      this.stream.next({\n        type: InternalStreamMessageType.NewValuesSameSchema,\n        values: this.frameBuffer.getValuesFromLastPacket(),\n      });\n    }\n  };\n\n  private resizeBuffer = (bufferOptions: StreamingFrameOptions) => {\n    if (bufferOptions && this.frameBuffer.needsResizing(bufferOptions)) {\n      this.frameBuffer.resize(bufferOptions);\n    }\n  };\n\n  private prepareInternalStreamForNewSubscription = (options: LiveDataStreamOptions): void => {\n    if (!this.frameBuffer.hasAtLeastOnePacket() && options.frame) {\n      // will skip initial frames from subsequent subscribers\n      this.process(options.frame);\n    }\n  };\n\n  private clearShutdownTimeout = () => {\n    if (this.shutdownTimeoutId) {\n      clearTimeout(this.shutdownTimeoutId);\n      this.shutdownTimeoutId = undefined;\n    }\n  };\n\n  get = (options: LiveDataStreamOptions, subKey: DataStreamSubscriptionKey): Observable<StreamingDataQueryResponse> => {\n    this.clearShutdownTimeout();\n    const buffer = getStreamingFrameOptions(options.buffer);\n\n    this.resizeBuffer(buffer);\n    this.prepareInternalStreamForNewSubscription(options);\n\n    const shouldSendLastPacketOnly = options?.buffer?.action === StreamingFrameAction.Replace;\n    const fieldsNamesFilter = options.filter?.fields;\n    const dataNeedsFiltering = fieldsNamesFilter?.length;\n    const fieldFilterPredicate = dataNeedsFiltering ? ({ name }: Field) => fieldsNamesFilter.includes(name) : undefined;\n    let matchingFieldIndexes: number[] | undefined = undefined;\n\n    const getFullFrameResponseData = <T>(\n      messages: InternalStreamMessage[],\n      error?: DataQueryError\n    ): StreamingDataQueryResponse => {\n      matchingFieldIndexes = fieldFilterPredicate\n        ? this.frameBuffer.getMatchingFieldIndexes(fieldFilterPredicate)\n        : undefined;\n\n      if (!shouldSendLastPacketOnly) {\n        return {\n          key: subKey,\n          state: error ? LoadingState.Error : LoadingState.Streaming,\n          data: [\n            {\n              type: StreamingResponseDataType.FullFrame,\n              frame: this.frameBuffer.serialize(fieldFilterPredicate, buffer),\n            },\n          ],\n          error,\n        };\n      }\n\n      if (error) {\n        // send empty frame with error\n        return {\n          key: subKey,\n          state: LoadingState.Error,\n          data: [\n            {\n              type: StreamingResponseDataType.FullFrame,\n              frame: this.frameBuffer.serialize(fieldFilterPredicate, buffer, { maxLength: 0 }),\n            },\n          ],\n          error,\n        };\n      }\n\n      if (!messages.length) {\n        console.warn(`expected to find at least one non error message ${messages.map(({ type }) => type)}`);\n        // send empty frame\n        return {\n          key: subKey,\n          state: LoadingState.Streaming,\n          data: [\n            {\n              type: StreamingResponseDataType.FullFrame,\n              frame: this.frameBuffer.serialize(fieldFilterPredicate, buffer, { maxLength: 0 }),\n            },\n          ],\n          error,\n        };\n      }\n\n      return {\n        key: subKey,\n        state: LoadingState.Streaming,\n        data: [\n          {\n            type: StreamingResponseDataType.FullFrame,\n            frame: this.frameBuffer.serialize(fieldFilterPredicate, buffer, {\n              maxLength: this.frameBuffer.packetInfo.length,\n            }),\n          },\n        ],\n        error,\n      };\n    };\n\n    const getNewValuesSameSchemaResponseData = (\n      messages: Array<InternalStreamMessage<InternalStreamMessageType.NewValuesSameSchema>>\n    ): StreamingDataQueryResponse => {\n      const lastMessage = messages.length ? messages[messages.length - 1] : undefined;\n      const values =\n        shouldSendLastPacketOnly && lastMessage\n          ? lastMessage.values\n          : reduceNewValuesSameSchemaMessages(messages).values;\n\n      const filteredValues = matchingFieldIndexes\n        ? values.filter((v, i) => (matchingFieldIndexes as number[]).includes(i))\n        : values;\n\n      return {\n        key: subKey,\n        state: LoadingState.Streaming,\n        data: [\n          {\n            type: StreamingResponseDataType.NewValuesSameSchema,\n            values: filteredValues,\n          },\n        ],\n      };\n    };\n\n    let shouldSendFullFrame = true;\n    const transformedInternalStream = this.stream.pipe(\n      bufferIfNot(this.deps.subscriberReadiness),\n      map((messages, i) => {\n        const errors = filterMessages(messages, InternalStreamMessageType.Error);\n        const lastError = errors.length ? errors[errors.length - 1].error : undefined;\n\n        if (shouldSendFullFrame) {\n          shouldSendFullFrame = false;\n          return getFullFrameResponseData(messages, lastError);\n        }\n\n        if (errors.length) {\n          // send the latest frame with the last error, discard everything else\n          return getFullFrameResponseData(messages, lastError);\n        }\n\n        const schemaChanged = messages.some((n) => n.type === InternalStreamMessageType.ChangedSchema);\n        if (schemaChanged) {\n          // send the latest frame, discard intermediate appends\n          return getFullFrameResponseData(messages, undefined);\n        }\n\n        const newValueSameSchemaMessages = filterMessages(messages, InternalStreamMessageType.NewValuesSameSchema);\n        if (newValueSameSchemaMessages.length !== messages.length) {\n          console.warn(`unsupported message type ${messages.map(({ type }) => type)}`);\n        }\n\n        return getNewValuesSameSchemaResponseData(newValueSameSchemaMessages);\n      })\n    );\n\n    return new Observable<StreamingDataQueryResponse>((subscriber) => {\n      const sub = transformedInternalStream.subscribe({\n        next: (n) => {\n          subscriber.next(n);\n        },\n        error: (err) => {\n          subscriber.error(err);\n        },\n        complete: () => {\n          subscriber.complete();\n        },\n      });\n\n      return () => {\n        // TODO: potentially resize (downsize) the buffer on unsubscribe\n        sub.unsubscribe();\n        if (!this.stream.observed) {\n          this.clearShutdownTimeout();\n          this.shutdownTimeoutId = setTimeout(this.shutdownIfNoSubscribers, this.deps.shutdownDelayInMs);\n        }\n      };\n    });\n  };\n}\n","import {\n  Subscription,\n  JoinContext,\n  LeaveContext,\n  PublicationContext,\n  SubscriptionErrorContext,\n  SubscribedContext,\n} from 'centrifuge';\nimport { Subject, of, Observable } from 'rxjs';\n\nimport {\n  LiveChannelStatusEvent,\n  LiveChannelEvent,\n  LiveChannelEventType,\n  LiveChannelConnectionState,\n  LiveChannelPresenceStatus,\n  LiveChannelAddress,\n  DataFrameJSON,\n  isValidLiveChannelAddress,\n} from '@grafana/data';\n\n/**\n * Internal class that maps Centrifuge support to GrafanaLive\n */\nexport class CentrifugeLiveChannel<T = any> {\n  readonly currentStatus: LiveChannelStatusEvent;\n\n  readonly opened = Date.now();\n  readonly id: string;\n  readonly addr: LiveChannelAddress;\n\n  readonly stream = new Subject<LiveChannelEvent<T>>();\n\n  // Hold on to the last header with schema\n  lastMessageWithSchema?: DataFrameJSON;\n\n  subscription?: Subscription;\n  shutdownCallback?: () => void;\n  initalized?: boolean;\n\n  constructor(id: string, addr: LiveChannelAddress) {\n    this.id = id;\n    this.addr = addr;\n    this.currentStatus = {\n      type: LiveChannelEventType.Status,\n      id,\n      timestamp: this.opened,\n      state: LiveChannelConnectionState.Pending,\n    };\n    if (!isValidLiveChannelAddress(addr)) {\n      this.currentStatus.state = LiveChannelConnectionState.Invalid;\n      this.currentStatus.error = 'invalid channel address';\n    }\n  }\n\n  // This should only be called when centrifuge is connected\n  initalize(): void {\n    if (this.initalized) {\n      throw new Error('Channel already initalized: ' + this.id);\n    }\n    this.initalized = true;\n\n    this.subscription!.on('publication', (ctx: PublicationContext) => {\n      try {\n        if (ctx.data) {\n          if (ctx.data.schema) {\n            this.lastMessageWithSchema = ctx.data as DataFrameJSON;\n          }\n\n          this.stream.next({\n            type: LiveChannelEventType.Message,\n            message: ctx.data,\n          });\n        }\n\n        // Clear any error messages\n        if (this.currentStatus.error) {\n          this.currentStatus.timestamp = Date.now();\n          delete this.currentStatus.error;\n          this.sendStatus();\n        }\n      } catch (err) {\n        console.log('publish error', this.addr, err);\n        this.currentStatus.error = err;\n        this.currentStatus.timestamp = Date.now();\n        this.sendStatus();\n      }\n    })\n      .on('error', (ctx: SubscriptionErrorContext) => {\n        this.currentStatus.timestamp = Date.now();\n        this.currentStatus.error = ctx.error.message;\n        this.sendStatus();\n      })\n      .on('subscribed', (ctx: SubscribedContext) => {\n        this.currentStatus.timestamp = Date.now();\n        this.currentStatus.state = LiveChannelConnectionState.Connected;\n        delete this.currentStatus.error;\n\n        if (ctx.data?.schema) {\n          this.lastMessageWithSchema = ctx.data as DataFrameJSON;\n        }\n        this.sendStatus(ctx.data);\n      })\n      .on('unsubscribed', () => {\n        this.currentStatus.timestamp = Date.now();\n        this.currentStatus.state = LiveChannelConnectionState.Disconnected;\n        this.sendStatus();\n      })\n      .on('subscribing', () => {\n        this.currentStatus.timestamp = Date.now();\n        this.currentStatus.state = LiveChannelConnectionState.Connecting;\n        this.sendStatus();\n      })\n      .on('join', (ctx: JoinContext) => {\n        this.stream.next({ type: LiveChannelEventType.Join, user: ctx.info.user });\n      })\n      .on('leave', (ctx: LeaveContext) => {\n        this.stream.next({ type: LiveChannelEventType.Leave, user: ctx.info.user });\n      });\n  }\n\n  private sendStatus(message?: any) {\n    const copy = { ...this.currentStatus };\n    if (message) {\n      copy.message = message;\n    }\n    this.stream.next(copy);\n  }\n\n  disconnectIfNoListeners = () => {\n    const count = this.stream.observers.length;\n    if (count === 0) {\n      this.disconnect();\n    }\n  };\n\n  /**\n   * Get the stream of events and\n   */\n  getStream() {\n    return new Observable((subscriber) => {\n      const initialMessage = { ...this.currentStatus };\n      if (this.lastMessageWithSchema?.schema) {\n        // send just schema instead of schema+data to avoid having data gaps\n        initialMessage.message = { schema: this.lastMessageWithSchema?.schema };\n      }\n\n      subscriber.next({ ...this.currentStatus, message: this.lastMessageWithSchema });\n\n      const sub = this.stream.subscribe(subscriber);\n      return () => {\n        sub.unsubscribe();\n        const count = this.stream.observers.length;\n\n        // Wait 1/4 second to fully disconnect\n        if (count === 0) {\n          setTimeout(this.disconnectIfNoListeners, 250);\n        }\n      };\n    }) as Observable<LiveChannelEvent<T>>;\n  }\n\n  /**\n   * This is configured by the server when the config supports presence\n   */\n  async getPresence(): Promise<LiveChannelPresenceStatus> {\n    if (!this.subscription) {\n      return Promise.reject('not subscribed');\n    }\n\n    return this.subscription!.presence().then((v) => {\n      return {\n        users: Object.keys(v.clients),\n      };\n    });\n  }\n\n  /**\n   * This will close and terminate all streams for this channel\n   */\n  disconnect() {\n    this.currentStatus.state = LiveChannelConnectionState.Shutdown;\n    this.currentStatus.timestamp = Date.now();\n\n    if (this.subscription) {\n      this.subscription.unsubscribe();\n      this.subscription.removeAllListeners(); // they keep all listeners attached after unsubscribe\n      this.subscription = undefined;\n    }\n\n    this.stream.complete();\n\n    this.stream.next({ ...this.currentStatus });\n    this.stream.complete();\n\n    if (this.shutdownCallback) {\n      this.shutdownCallback();\n    }\n  }\n\n  shutdownWithError(err: string) {\n    this.currentStatus.error = err;\n    this.sendStatus();\n    this.disconnect();\n  }\n}\n\nexport function getErrorChannel<TMessage>(msg: string, id: string, addr: LiveChannelAddress) {\n  return {\n    id,\n    opened: Date.now(),\n    addr,\n\n    // return an error\n    getStream: () =>\n      of({\n        type: LiveChannelEventType.Status,\n        id,\n        timestamp: Date.now(),\n        state: LiveChannelConnectionState.Invalid,\n        error: msg,\n      }),\n\n    // already disconnected\n    disconnect: () => {},\n  };\n}\n","import { Centrifuge, State } from 'centrifuge';\nimport { BehaviorSubject, Observable, share, startWith } from 'rxjs';\n\nimport {\n  DataQueryError,\n  DataQueryResponse,\n  LiveChannelAddress,\n  LiveChannelConnectionState,\n  LiveChannelId,\n  toLiveChannelId,\n} from '@grafana/data';\nimport { FetchResponse } from '@grafana/runtime/src/services/backendSrv';\nimport {\n  GrafanaLiveSrv,\n  LiveDataStreamOptions,\n  LiveQueryDataOptions,\n  StreamingFrameAction,\n  StreamingFrameOptions,\n} from '@grafana/runtime/src/services/live';\nimport { BackendDataSourceResponse } from '@grafana/runtime/src/utils/queryResponse';\n\nimport { StreamingResponseData } from '../data/utils';\n\nimport { LiveDataStream } from './LiveDataStream';\nimport { CentrifugeLiveChannel } from './channel';\n\nexport type CentrifugeSrvDeps = {\n  grafanaAuthToken: string | null;\n  appUrl: string;\n  orgId: number;\n  orgRole: string;\n  sessionId: string;\n  liveEnabled: boolean;\n  dataStreamSubscriberReadiness: Observable<boolean>;\n};\n\nexport type StreamingDataQueryResponse = Omit<DataQueryResponse, 'data'> & { data: [StreamingResponseData] };\n\nexport type CentrifugeSrv = Omit<GrafanaLiveSrv, 'publish' | 'getDataStream' | 'getQueryData'> & {\n  getDataStream: (options: LiveDataStreamOptions) => Observable<StreamingDataQueryResponse>;\n  getQueryData: (\n    options: LiveQueryDataOptions\n  ) => Promise<\n    | { data: BackendDataSourceResponse | undefined }\n    | FetchResponse<BackendDataSourceResponse | undefined>\n    | DataQueryError\n  >;\n};\n\nexport type DataStreamSubscriptionKey = string;\n\nconst defaultStreamingFrameOptions: Readonly<StreamingFrameOptions> = {\n  maxLength: 100,\n  maxDelta: Infinity,\n  action: StreamingFrameAction.Append,\n};\n\nconst dataStreamShutdownDelayInMs = 5000;\n\nexport class CentrifugeService implements CentrifugeSrv {\n  readonly open = new Map<string, CentrifugeLiveChannel>();\n  private readonly liveDataStreamByChannelId: Record<LiveChannelId, LiveDataStream> = {};\n  readonly centrifuge: Centrifuge;\n  readonly connectionState: BehaviorSubject<boolean>;\n  readonly connectionBlocker: Promise<void>;\n  private readonly dataStreamSubscriberReadiness: Observable<boolean>;\n\n  constructor(private deps: CentrifugeSrvDeps) {\n    this.dataStreamSubscriberReadiness = deps.dataStreamSubscriberReadiness.pipe(share(), startWith(true));\n\n    let liveUrl = `${deps.appUrl.replace(/^http/, 'ws')}/api/live/ws`;\n\n    const token = deps.grafanaAuthToken;\n    if (token !== null && token !== '') {\n      liveUrl += '?auth_token=' + token;\n    }\n\n    this.centrifuge = new Centrifuge(liveUrl, {\n      timeout: 30000,\n    });\n    // orgRole is set when logged in *or* anonymous users can use grafana\n    if (deps.liveEnabled && deps.orgRole !== '') {\n      this.centrifuge.connect(); // do connection\n    }\n    this.connectionState = new BehaviorSubject<boolean>(this.centrifuge.state === State.Connected);\n    this.connectionBlocker = new Promise<void>((resolve) => {\n      if (this.centrifuge.state === State.Connected) {\n        return resolve();\n      }\n      const connectListener = () => {\n        resolve();\n        this.centrifuge.removeListener('connected', connectListener);\n      };\n      this.centrifuge.addListener('connected', connectListener);\n    });\n\n    // Register global listeners\n    this.centrifuge.on('connected', this.onConnect);\n    this.centrifuge.on('connecting', this.onDisconnect);\n    this.centrifuge.on('disconnected', this.onDisconnect);\n    this.centrifuge.on('publication', this.onServerSideMessage);\n  }\n\n  //----------------------------------------------------------\n  // Internal functions\n  //----------------------------------------------------------\n\n  private onConnect = (context: any) => {\n    this.connectionState.next(true);\n  };\n\n  private onDisconnect = (context: any) => {\n    this.connectionState.next(false);\n  };\n\n  private onServerSideMessage = (context: any) => {\n    console.log('Publication from server-side channel', context);\n  };\n\n  /**\n   * Get a channel.  If the scope, namespace, or path is invalid, a shutdown\n   * channel will be returned with an error state indicated in its status\n   */\n  private getChannel<TMessage>(addr: LiveChannelAddress): CentrifugeLiveChannel<TMessage> {\n    const id = `${this.deps.orgId}/${addr.scope}/${addr.namespace}/${addr.path}`;\n    let channel = this.open.get(id);\n    if (channel != null) {\n      return channel;\n    }\n\n    channel = new CentrifugeLiveChannel(id, addr);\n    if (channel.currentStatus.state === LiveChannelConnectionState.Invalid) {\n      return channel;\n    }\n    channel.shutdownCallback = () => {\n      this.open.delete(id);\n\n      // without a call to `removeSubscription`, the subscription will remain in centrifuge's internal registry\n      this.centrifuge.removeSubscription(this.centrifuge.getSubscription(id));\n    };\n    this.open.set(id, channel);\n\n    // Initialize the channel in the background\n    this.initChannel(channel).catch((err) => {\n      if (channel) {\n        channel.currentStatus.state = LiveChannelConnectionState.Invalid;\n        channel.shutdownWithError(err);\n      }\n      this.open.delete(id);\n    });\n\n    // return the not-yet initialized channel\n    return channel;\n  }\n\n  private async initChannel(channel: CentrifugeLiveChannel): Promise<void> {\n    if (this.centrifuge.state !== State.Connected) {\n      await this.connectionBlocker;\n    }\n    const subscription = this.centrifuge.newSubscription(channel.id, {\n      data: channel.addr.data,\n    });\n    channel.subscription = subscription;\n    channel.initalize();\n    subscription.subscribe();\n    return;\n  }\n\n  //----------------------------------------------------------\n  // Exported functions\n  //----------------------------------------------------------\n\n  /**\n   * Listen for changes to the connection state\n   */\n  getConnectionState = () => {\n    return this.connectionState.asObservable();\n  };\n\n  /**\n   * Watch for messages in a channel\n   */\n  getStream: CentrifugeSrv['getStream'] = <T>(address: LiveChannelAddress) => {\n    return this.getChannel<T>(address).getStream();\n  };\n\n  private createSubscriptionKey = (options: LiveDataStreamOptions): DataStreamSubscriptionKey =>\n    options.key ?? `xstr/${streamCounter++}`;\n\n  private getLiveDataStream = (options: LiveDataStreamOptions): LiveDataStream => {\n    const channelId = toLiveChannelId(options.addr);\n    const existingStream = this.liveDataStreamByChannelId[channelId];\n\n    if (existingStream) {\n      return existingStream;\n    }\n\n    const channel = this.getChannel(options.addr);\n    this.liveDataStreamByChannelId[channelId] = new LiveDataStream({\n      channelId,\n      onShutdown: () => {\n        delete this.liveDataStreamByChannelId[channelId];\n      },\n      liveEventsObservable: channel.getStream(),\n      subscriberReadiness: this.dataStreamSubscriberReadiness,\n      defaultStreamingFrameOptions,\n      shutdownDelayInMs: dataStreamShutdownDelayInMs,\n    });\n    return this.liveDataStreamByChannelId[channelId];\n  };\n  /**\n   * Connect to a channel and return results as DataFrames\n   */\n  getDataStream: CentrifugeSrv['getDataStream'] = (options) => {\n    const subscriptionKey = this.createSubscriptionKey(options);\n\n    const stream = this.getLiveDataStream(options);\n    return stream.get(options, subscriptionKey);\n  };\n\n  /**\n   * Executes a query over the live websocket. Query response can contain live channels we can subscribe to for further updates\n   *\n   * Since the initial request and subscription are on the same socket, this will support HA setups\n   */\n  getQueryData: CentrifugeSrv['getQueryData'] = async (options) => {\n    if (this.centrifuge.state !== State.Connected) {\n      await this.connectionBlocker;\n    }\n    return this.centrifuge.rpc('grafana.query', options.body);\n  };\n\n  /**\n   * For channels that support presence, this will request the current state from the server.\n   *\n   * Join and leave messages will be sent to the open stream\n   */\n  getPresence: CentrifugeSrv['getPresence'] = (address) => {\n    return this.getChannel(address).getPresence();\n  };\n}\n\n// This is used to give a unique key for each stream.  The actual value does not matter\nlet streamCounter = 0;\n","import * as comlink from 'comlink';\nimport { Subscriber } from 'rxjs';\n\n// Observers, ie. functions passed to `observable.subscribe(...)`, are converted to a subclass of `Subscriber` before they are sent to the source Observable.\n// The conversion happens internally in the RxJS library - this transfer handler is catches them and wraps them with a proxy\nconst subscriberTransferHandler: any = {\n  canHandle(value: any): boolean {\n    return value && value instanceof Subscriber;\n  },\n\n  serialize(value: Function): [MessagePort, Transferable[]] {\n    const obj = comlink.proxy(value);\n\n    const { port1, port2 } = new MessageChannel();\n\n    comlink.expose(obj, port1);\n\n    return [port2, [port2]];\n  },\n\n  deserialize(value: MessagePort): comlink.Remote<MessagePort> {\n    value.start();\n\n    return comlink.wrap<MessagePort>(value);\n  },\n};\ncomlink.transferHandlers.set('SubscriberHandler', subscriberTransferHandler);\n","import { Labels } from '@grafana/data';\n\n/** replace labels in a string.  Used for loki+prometheus legend formats */\nexport function renderLegendFormat(aliasPattern: string, aliasData: Labels): string {\n  const aliasRegex = /\\{\\{\\s*(.+?)\\s*\\}\\}/g;\n  return aliasPattern.replace(aliasRegex, (_, g1) => (aliasData[g1] ? aliasData[g1] : g1));\n}\n"],"names":["fieldIndexComparer","field","reverse","values","numericIndexComparer","stringIndexComparer","booleanIndexComparer","timeIndexComparer","naturalIndexComparer","timeComparer","a","b","falsyComparer","numericComparer","stringComparer","booleanComparer","vA","vB","fieldTypeMatcher","type","frame","allFrames","numericMatcher","timeMatcher","getFieldTypeMatchers","MatcherID","FieldMatcherID","FrameMatcherID","ValueMatcherID","refIdMacher","pattern","regex","getRefIdMatchers","firstFieldMatcher","firstTimeFieldMatcher","f","getSimpleFieldMatchers","isEqualValueMatcher","options","valueIndex","isNotEqualValueMatcher","getEqualValueMatchers","isNullValueMatcher","isNotNullValueMatcher","getNullValueMatchers","isGreaterValueMatcher","value","isGreaterOrEqualValueMatcher","isLowerValueMatcher","isLowerOrEqualValueMatcher","getNumericValueMatchers","isBetweenValueMatcher","getRangeValueMatchers","regexValueMatcher","getRegexValueMatcher","DataTransformerID","Registry","init","id","ext","v","current","filter","select","currentOptions","option","ids","found","alias","ArrayVector","buffer","index","SortedVector","source","order","vectorToArray","arr","i","toDataQueryError","err","error","message","bufferIfNot","canEmitObservable","Observable","subscriber","canEmit","emitBuffer","canEmitSub","val","sourceSub","InternalStreamMessageType","reduceNewValuesSameSchemaMessages","packets","acc","j","filterMessages","p","LiveDataStream","deps","ReplaySubject","evt","liveChannelStatusEvent","msg","bufferOptions","subKey","shouldSendLastPacketOnly","fieldsNamesFilter","fieldFilterPredicate","name","matchingFieldIndexes","getFullFrameResponseData","messages","getNewValuesSameSchemaResponseData","lastMessage","filteredValues","shouldSendFullFrame","transformedInternalStream","map","errors","lastError","n","newValueSameSchemaMessages","sub","StreamingDataFrame","CentrifugeLiveChannel","addr","Subject","ctx","copy","initialMessage","getErrorChannel","defaultStreamingFrameOptions","dataStreamShutdownDelayInMs","CentrifugeService","context","address","streamCounter","channelId","existingStream","channel","subscriptionKey","share","startWith","liveUrl","token","BehaviorSubject","resolve","connectListener","subscription","subscriberTransferHandler","obj","port1","port2","renderLegendFormat","aliasPattern","aliasData","aliasRegex","_","g1"],"sourceRoot":""}