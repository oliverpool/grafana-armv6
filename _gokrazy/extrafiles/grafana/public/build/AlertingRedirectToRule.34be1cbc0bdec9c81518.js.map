{"version":3,"file":"AlertingRedirectToRule.34be1cbc0bdec9c81518.js","mappings":"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","sources":["webpack://grafana/./.yarn/__virtual__/react-use-virtual-720cbd4f86/3/opt/drone/yarncache/react-use-npm-17.4.0-0ef4521544-0889da919b.zip/node_modules/react-use/esm/useLocation.js","webpack://grafana/./public/app/features/alerting/unified/RedirectToRuleViewer.tsx","webpack://grafana/./public/app/features/alerting/unified/components/rule-viewer/RuleViewerLayout.tsx","webpack://grafana/./public/app/features/alerting/unified/hooks/useCombinedRule.ts","webpack://grafana/./public/app/features/alerting/unified/hooks/useCombinedRuleNamespaces.ts"],"sourcesContent":["import { useEffect, useState } from 'react';\nimport { isBrowser, off, on } from './misc/util';\nvar patchHistoryMethod = function (method) {\n    var history = window.history;\n    var original = history[method];\n    history[method] = function (state) {\n        var result = original.apply(this, arguments);\n        var event = new Event(method.toLowerCase());\n        event.state = state;\n        window.dispatchEvent(event);\n        return result;\n    };\n};\nif (isBrowser) {\n    patchHistoryMethod('pushState');\n    patchHistoryMethod('replaceState');\n}\nvar useLocationServer = function () { return ({\n    trigger: 'load',\n    length: 1,\n}); };\nvar buildState = function (trigger) {\n    var _a = window.history, state = _a.state, length = _a.length;\n    var _b = window.location, hash = _b.hash, host = _b.host, hostname = _b.hostname, href = _b.href, origin = _b.origin, pathname = _b.pathname, port = _b.port, protocol = _b.protocol, search = _b.search;\n    return {\n        trigger: trigger,\n        state: state,\n        length: length,\n        hash: hash,\n        host: host,\n        hostname: hostname,\n        href: href,\n        origin: origin,\n        pathname: pathname,\n        port: port,\n        protocol: protocol,\n        search: search,\n    };\n};\nvar useLocationBrowser = function () {\n    var _a = useState(buildState('load')), state = _a[0], setState = _a[1];\n    useEffect(function () {\n        var onPopstate = function () { return setState(buildState('popstate')); };\n        var onPushstate = function () { return setState(buildState('pushstate')); };\n        var onReplacestate = function () { return setState(buildState('replacestate')); };\n        on(window, 'popstate', onPopstate);\n        on(window, 'pushstate', onPushstate);\n        on(window, 'replacestate', onReplacestate);\n        return function () {\n            off(window, 'popstate', onPopstate);\n            off(window, 'pushstate', onPushstate);\n            off(window, 'replacestate', onReplacestate);\n        };\n    }, []);\n    return state;\n};\nvar hasEventConstructor = typeof Event === 'function';\nexport default isBrowser && hasEventConstructor ? useLocationBrowser : useLocationServer;\n","import { css } from '@emotion/css';\nimport React from 'react';\nimport { Redirect } from 'react-router-dom';\nimport { useLocation } from 'react-use';\n\nimport { GrafanaTheme2 } from '@grafana/data';\nimport { Alert, Card, Icon, LoadingPlaceholder, useStyles2, withErrorBoundary } from '@grafana/ui';\n\nimport { AlertLabels } from './components/AlertLabels';\nimport { RuleViewerLayout } from './components/rule-viewer/RuleViewerLayout';\nimport { useCombinedRulesMatching } from './hooks/useCombinedRule';\nimport { getRulesSourceByName } from './utils/datasource';\nimport { createViewLink } from './utils/misc';\n\nconst pageTitle = 'Find rule';\n\nfunction useRuleFindParams() {\n  // DO NOT USE REACT-ROUTER HOOKS FOR THIS CODE\n  // React-router's useLocation/useParams/props.match are broken and don't preserve original param values when parsing location\n  // so, they cannot be used to parse name and sourceName path params\n  // React-router messes the pathname up resulting in a string that is neither encoded nor decoded\n  // Relevant issue: https://github.com/remix-run/history/issues/505#issuecomment-453175833\n  // It was probably fixed in React-Router v6\n  const location = useLocation();\n  const segments = location.pathname?.split('/') ?? []; // [\"\", \"alerting\", \"{sourceName}\", \"{name}]\n\n  const name = decodeURIComponent(segments[3]);\n  const sourceName = decodeURIComponent(segments[2]);\n\n  return { name, sourceName };\n}\n\nexport function RedirectToRuleViewer(): JSX.Element | null {\n  const styles = useStyles2(getStyles);\n\n  const { name, sourceName } = useRuleFindParams();\n  const { error, loading, result: rules, dispatched } = useCombinedRulesMatching(name, sourceName);\n\n  if (error) {\n    return (\n      <RuleViewerLayout title={pageTitle}>\n        <Alert title={`Failed to load rules from ${sourceName}`}>\n          <details className={styles.errorMessage}>\n            {error.message}\n            <br />\n            {!!error?.stack && error.stack}\n          </details>\n        </Alert>\n      </RuleViewerLayout>\n    );\n  }\n\n  if (loading || !dispatched || !Array.isArray(rules)) {\n    return (\n      <RuleViewerLayout title={pageTitle}>\n        <LoadingPlaceholder text=\"Loading rule...\" />\n      </RuleViewerLayout>\n    );\n  }\n\n  if (!name || !sourceName) {\n    return <Redirect to=\"/notfound\" />;\n  }\n\n  const rulesSource = getRulesSourceByName(sourceName);\n\n  if (!rulesSource) {\n    return (\n      <RuleViewerLayout title={pageTitle}>\n        <Alert title=\"Could not view rule\">\n          <details className={styles.errorMessage}>{`Could not find data source with name: ${sourceName}.`}</details>\n        </Alert>\n      </RuleViewerLayout>\n    );\n  }\n\n  if (rules.length === 1) {\n    const [rule] = rules;\n    return <Redirect to={createViewLink(rulesSource, rule, '/alerting/list')} />;\n  }\n\n  return (\n    <RuleViewerLayout title={pageTitle}>\n      <div>\n        Several rules in <span className={styles.param}>{sourceName}</span> matched the name{' '}\n        <span className={styles.param}>{name}</span>, please select the rule you want to view.\n      </div>\n      <div className={styles.rules}>\n        {rules.map((rule, index) => {\n          return (\n            <Card key={`${rule.name}-${index}`} href={createViewLink(rulesSource, rule, '/alerting/list')}>\n              <Card.Heading>{rule.name}</Card.Heading>\n              <Card.Meta separator={''}>\n                <Icon name=\"folder\" />\n                <span className={styles.namespace}>{`${rule.namespace.name} / ${rule.group.name}`}</span>\n              </Card.Meta>\n              <Card.Tags>\n                <AlertLabels labels={rule.labels} />\n              </Card.Tags>\n            </Card>\n          );\n        })}\n      </div>\n    </RuleViewerLayout>\n  );\n}\n\nfunction getStyles(theme: GrafanaTheme2) {\n  return {\n    param: css`\n      font-style: italic;\n      color: ${theme.colors.text.secondary};\n    `,\n    rules: css`\n      margin-top: ${theme.spacing(2)};\n    `,\n    namespace: css`\n      margin-left: ${theme.spacing(1)};\n    `,\n    errorMessage: css`\n      white-space: pre-wrap;\n    `,\n  };\n}\n\nexport default withErrorBoundary(RedirectToRuleViewer, { style: 'page' });\n","import { css } from '@emotion/css';\nimport React from 'react';\n\nimport { GrafanaTheme2, NavModelItem } from '@grafana/data';\nimport { useStyles2 } from '@grafana/ui';\nimport { Page } from 'app/core/components/Page/Page';\n\ntype Props = {\n  children: React.ReactNode | React.ReactNode[];\n  title: string;\n  wrapInContent?: boolean;\n};\n\nconst defaultPageNav: Partial<NavModelItem> = {\n  icon: 'bell',\n  id: 'alert-rule-view',\n  breadcrumbs: [{ title: 'Alert rules', url: 'alerting/list' }],\n};\n\nexport function RuleViewerLayout(props: Props): JSX.Element | null {\n  const { wrapInContent = true, children, title } = props;\n  const styles = useStyles2(getPageStyles);\n\n  return (\n    <Page pageNav={{ ...defaultPageNav, text: title }} navId=\"alert-list\">\n      <Page.Contents>\n        <div className={styles.content}>{wrapInContent ? <RuleViewerLayoutContent {...props} /> : children}</div>\n      </Page.Contents>\n    </Page>\n  );\n}\n\ntype ContentProps = {\n  children: React.ReactNode | React.ReactNode[];\n  padding?: number;\n};\n\nexport function RuleViewerLayoutContent({ children, padding = 2 }: ContentProps): JSX.Element | null {\n  const styles = useStyles2(getContentStyles(padding));\n  return <div className={styles.wrapper}>{children}</div>;\n}\n\nconst getPageStyles = (theme: GrafanaTheme2) => {\n  return {\n    content: css`\n      max-width: ${theme.breakpoints.values.xxl}px;\n    `,\n  };\n};\n\nconst getContentStyles = (padding: number) => (theme: GrafanaTheme2) => {\n  return {\n    wrapper: css`\n      background: ${theme.colors.background.primary};\n      border: 1px solid ${theme.colors.border.weak};\n      border-radius: ${theme.shape.borderRadius()};\n      padding: ${theme.spacing(padding)};\n    `,\n  };\n};\n","import { useMemo } from 'react';\nimport { useAsync } from 'react-use';\n\nimport { useDispatch } from 'app/types';\nimport { CombinedRule, RuleIdentifier, RuleNamespace } from 'app/types/unified-alerting';\nimport { RulerRulesConfigDTO } from 'app/types/unified-alerting-dto';\n\nimport { fetchPromAndRulerRulesAction } from '../state/actions';\nimport { AsyncRequestMapSlice, AsyncRequestState, initialAsyncRequestState } from '../utils/redux';\nimport * as ruleId from '../utils/rule-id';\nimport { isRulerNotSupportedResponse } from '../utils/rules';\n\nimport { useCombinedRuleNamespaces } from './useCombinedRuleNamespaces';\nimport { useUnifiedAlertingSelector } from './useUnifiedAlertingSelector';\n\nexport function useCombinedRule(\n  identifier: RuleIdentifier | undefined,\n  ruleSourceName: string | undefined\n): AsyncRequestState<CombinedRule> {\n  const requestState = useCombinedRulesLoader(ruleSourceName);\n  const combinedRules = useCombinedRuleNamespaces(ruleSourceName);\n\n  const rule = useMemo(() => {\n    if (!identifier || !ruleSourceName || combinedRules.length === 0) {\n      return;\n    }\n\n    for (const namespace of combinedRules) {\n      for (const group of namespace.groups) {\n        for (const rule of group.rules) {\n          const id = ruleId.fromCombinedRule(ruleSourceName, rule);\n\n          if (ruleId.equal(id, identifier)) {\n            return rule;\n          }\n        }\n      }\n    }\n\n    return;\n  }, [identifier, ruleSourceName, combinedRules]);\n\n  return {\n    ...requestState,\n    result: rule,\n  };\n}\n\nexport function useCombinedRulesMatching(\n  ruleName: string | undefined,\n  ruleSourceName: string | undefined\n): AsyncRequestState<CombinedRule[]> {\n  const requestState = useCombinedRulesLoader(ruleSourceName);\n  const combinedRules = useCombinedRuleNamespaces(ruleSourceName);\n\n  const rules = useMemo(() => {\n    if (!ruleName || !ruleSourceName || combinedRules.length === 0) {\n      return [];\n    }\n\n    const rules: CombinedRule[] = [];\n\n    for (const namespace of combinedRules) {\n      for (const group of namespace.groups) {\n        for (const rule of group.rules) {\n          if (rule.name === ruleName) {\n            rules.push(rule);\n          }\n        }\n      }\n    }\n\n    return rules;\n  }, [ruleName, ruleSourceName, combinedRules]);\n\n  return {\n    ...requestState,\n    result: rules,\n  };\n}\n\nfunction useCombinedRulesLoader(rulesSourceName: string | undefined): AsyncRequestState<void> {\n  const dispatch = useDispatch();\n  const promRuleRequests = useUnifiedAlertingSelector((state) => state.promRules);\n  const promRuleRequest = getRequestState(rulesSourceName, promRuleRequests);\n  const rulerRuleRequests = useUnifiedAlertingSelector((state) => state.rulerRules);\n  const rulerRuleRequest = getRequestState(rulesSourceName, rulerRuleRequests);\n\n  const { loading } = useAsync(async () => {\n    if (!rulesSourceName) {\n      return;\n    }\n\n    await dispatch(fetchPromAndRulerRulesAction({ rulesSourceName }));\n  }, [dispatch, rulesSourceName]);\n\n  return {\n    loading,\n    error: promRuleRequest.error ?? isRulerNotSupportedResponse(rulerRuleRequest) ? undefined : rulerRuleRequest.error,\n    dispatched: promRuleRequest.dispatched && rulerRuleRequest.dispatched,\n  };\n}\n\nfunction getRequestState(\n  ruleSourceName: string | undefined,\n  slice: AsyncRequestMapSlice<RulerRulesConfigDTO | RuleNamespace[] | null>\n): AsyncRequestState<RulerRulesConfigDTO | RuleNamespace[] | null> {\n  if (!ruleSourceName) {\n    return initialAsyncRequestState;\n  }\n\n  const state = slice[ruleSourceName];\n\n  if (!state) {\n    return initialAsyncRequestState;\n  }\n\n  return state;\n}\n","import { isEqual } from 'lodash';\nimport { useMemo, useRef } from 'react';\n\nimport {\n  CombinedRule,\n  CombinedRuleGroup,\n  CombinedRuleNamespace,\n  Rule,\n  RuleGroup,\n  RuleNamespace,\n  RulesSource,\n} from 'app/types/unified-alerting';\nimport { RulerRuleDTO, RulerRuleGroupDTO, RulerRulesConfigDTO } from 'app/types/unified-alerting-dto';\n\nimport {\n  getAllRulesSources,\n  getRulesSourceByName,\n  isCloudRulesSource,\n  isGrafanaRulesSource,\n} from '../utils/datasource';\nimport { isAlertingRule, isAlertingRulerRule, isRecordingRulerRule } from '../utils/rules';\n\nimport { useUnifiedAlertingSelector } from './useUnifiedAlertingSelector';\n\ninterface CacheValue {\n  promRules?: RuleNamespace[];\n  rulerRules?: RulerRulesConfigDTO | null;\n  result: CombinedRuleNamespace[];\n}\n\n// this little monster combines prometheus rules and ruler rules to produce a unified data structure\n// can limit to a single rules source\nexport function useCombinedRuleNamespaces(rulesSourceName?: string): CombinedRuleNamespace[] {\n  const promRulesResponses = useUnifiedAlertingSelector((state) => state.promRules);\n  const rulerRulesResponses = useUnifiedAlertingSelector((state) => state.rulerRules);\n\n  // cache results per rules source, so we only recalculate those for which results have actually changed\n  const cache = useRef<Record<string, CacheValue>>({});\n\n  const rulesSources = useMemo((): RulesSource[] => {\n    if (rulesSourceName) {\n      const rulesSource = getRulesSourceByName(rulesSourceName);\n      if (!rulesSource) {\n        throw new Error(`Unknown rules source: ${rulesSourceName}`);\n      }\n      return [rulesSource];\n    }\n    return getAllRulesSources();\n  }, [rulesSourceName]);\n\n  return useMemo(\n    () =>\n      rulesSources\n        .map((rulesSource): CombinedRuleNamespace[] => {\n          const rulesSourceName = isCloudRulesSource(rulesSource) ? rulesSource.name : rulesSource;\n          const promRules = promRulesResponses[rulesSourceName]?.result;\n          const rulerRules = rulerRulesResponses[rulesSourceName]?.result;\n\n          const cached = cache.current[rulesSourceName];\n          if (cached && cached.promRules === promRules && cached.rulerRules === rulerRules) {\n            return cached.result;\n          }\n          const namespaces: Record<string, CombinedRuleNamespace> = {};\n\n          // first get all the ruler rules in\n          Object.entries(rulerRules || {}).forEach(([namespaceName, groups]) => {\n            const namespace: CombinedRuleNamespace = {\n              rulesSource,\n              name: namespaceName,\n              groups: [],\n            };\n            namespaces[namespaceName] = namespace;\n            addRulerGroupsToCombinedNamespace(namespace, groups);\n          });\n\n          // then correlate with prometheus rules\n          promRules?.forEach(({ name: namespaceName, groups }) => {\n            const ns = (namespaces[namespaceName] = namespaces[namespaceName] || {\n              rulesSource,\n              name: namespaceName,\n              groups: [],\n            });\n\n            addPromGroupsToCombinedNamespace(ns, groups);\n          });\n\n          const result = Object.values(namespaces);\n\n          cache.current[rulesSourceName] = { promRules, rulerRules, result };\n          return result;\n        })\n        .flat(),\n    [promRulesResponses, rulerRulesResponses, rulesSources]\n  );\n}\n\n// merge all groups in case of grafana managed, essentially treating namespaces (folders) as groups\nexport function flattenGrafanaManagedRules(namespaces: CombinedRuleNamespace[]) {\n  return namespaces.map((namespace) => {\n    const newNamespace: CombinedRuleNamespace = {\n      ...namespace,\n      groups: [],\n    };\n\n    // add default group with ungrouped rules\n    newNamespace.groups.push({\n      name: 'default',\n      rules: sortRulesByName(namespace.groups.flatMap((group) => group.rules)),\n    });\n\n    return newNamespace;\n  });\n}\n\nexport function sortRulesByName(rules: CombinedRule[]) {\n  return rules.sort((a, b) => a.name.localeCompare(b.name));\n}\n\nfunction addRulerGroupsToCombinedNamespace(namespace: CombinedRuleNamespace, groups: RulerRuleGroupDTO[] = []): void {\n  namespace.groups = groups.map((group) => {\n    const combinedGroup: CombinedRuleGroup = {\n      name: group.name,\n      interval: group.interval,\n      source_tenants: group.source_tenants,\n      rules: [],\n    };\n    combinedGroup.rules = group.rules.map((rule) => rulerRuleToCombinedRule(rule, namespace, combinedGroup));\n    return combinedGroup;\n  });\n}\n\nfunction addPromGroupsToCombinedNamespace(namespace: CombinedRuleNamespace, groups: RuleGroup[]): void {\n  const existingGroupsByName = new Map<string, CombinedRuleGroup>();\n  namespace.groups.forEach((group) => existingGroupsByName.set(group.name, group));\n\n  groups.forEach((group) => {\n    let combinedGroup = existingGroupsByName.get(group.name);\n    if (!combinedGroup) {\n      combinedGroup = {\n        name: group.name,\n        rules: [],\n      };\n      namespace.groups.push(combinedGroup);\n      existingGroupsByName.set(group.name, combinedGroup);\n    }\n\n    const combinedRulesByName = new Map<string, CombinedRule[]>();\n    combinedGroup!.rules.forEach((r) => {\n      // Prometheus rules do not have to be unique by name\n      const existingRule = combinedRulesByName.get(r.name);\n      existingRule ? existingRule.push(r) : combinedRulesByName.set(r.name, [r]);\n    });\n\n    (group.rules ?? []).forEach((rule) => {\n      const existingRule = getExistingRuleInGroup(rule, combinedRulesByName, namespace.rulesSource);\n      if (existingRule) {\n        existingRule.promRule = rule;\n      } else {\n        combinedGroup!.rules.push(promRuleToCombinedRule(rule, namespace, combinedGroup!));\n      }\n    });\n  });\n}\n\nfunction promRuleToCombinedRule(rule: Rule, namespace: CombinedRuleNamespace, group: CombinedRuleGroup): CombinedRule {\n  return {\n    name: rule.name,\n    query: rule.query,\n    labels: rule.labels || {},\n    annotations: isAlertingRule(rule) ? rule.annotations || {} : {},\n    promRule: rule,\n    namespace: namespace,\n    group,\n  };\n}\n\nfunction rulerRuleToCombinedRule(\n  rule: RulerRuleDTO,\n  namespace: CombinedRuleNamespace,\n  group: CombinedRuleGroup\n): CombinedRule {\n  return isAlertingRulerRule(rule)\n    ? {\n        name: rule.alert,\n        query: rule.expr,\n        labels: rule.labels || {},\n        annotations: rule.annotations || {},\n        rulerRule: rule,\n        namespace,\n        group,\n      }\n    : isRecordingRulerRule(rule)\n    ? {\n        name: rule.record,\n        query: rule.expr,\n        labels: rule.labels || {},\n        annotations: {},\n        rulerRule: rule,\n        namespace,\n        group,\n      }\n    : {\n        name: rule.grafana_alert.title,\n        query: '',\n        labels: rule.labels || {},\n        annotations: rule.annotations || {},\n        rulerRule: rule,\n        namespace,\n        group,\n      };\n}\n\n// find existing rule in group that matches the given prom rule\nfunction getExistingRuleInGroup(\n  rule: Rule,\n  existingCombinedRulesMap: Map<string, CombinedRule[]>,\n  rulesSource: RulesSource\n): CombinedRule | undefined {\n  // Using Map of name-based rules is important performance optimization for the code below\n  // Otherwise we would perform find method multiple times on (possibly) thousands of rules\n\n  const nameMatchingRules = existingCombinedRulesMap.get(rule.name);\n  if (!nameMatchingRules) {\n    return undefined;\n  }\n\n  if (isGrafanaRulesSource(rulesSource)) {\n    // assume grafana groups have only the one rule. check name anyway because paranoid\n    return nameMatchingRules[0];\n  }\n\n  // try finding a rule that matches name, labels, annotations and query\n  const strictlyMatchingRule = nameMatchingRules.find(\n    (combinedRule) => !combinedRule.promRule && isCombinedRuleEqualToPromRule(combinedRule, rule, true)\n  );\n  if (strictlyMatchingRule) {\n    return strictlyMatchingRule;\n  }\n\n  // if that fails, try finding a rule that only matches name, labels and annotations.\n  // loki & prom can sometimes modify the query so it doesnt match, eg `2 > 1` becomes `1`\n  const looselyMatchingRule = nameMatchingRules.find(\n    (combinedRule) => !combinedRule.promRule && isCombinedRuleEqualToPromRule(combinedRule, rule, false)\n  );\n  if (looselyMatchingRule) {\n    return looselyMatchingRule;\n  }\n\n  return undefined;\n}\n\nfunction isCombinedRuleEqualToPromRule(combinedRule: CombinedRule, rule: Rule, checkQuery = true): boolean {\n  if (combinedRule.name === rule.name) {\n    return isEqual(\n      [checkQuery ? hashQuery(combinedRule.query) : '', combinedRule.labels, combinedRule.annotations],\n      [checkQuery ? hashQuery(rule.query) : '', rule.labels || {}, isAlertingRule(rule) ? rule.annotations || {} : {}]\n    );\n  }\n  return false;\n}\n\n// there can be slight differences in how prom & ruler render a query, this will hash them accounting for the differences\nfunction hashQuery(query: string) {\n  // one of them might be wrapped in parens\n  if (query.length > 1 && query[0] === '(' && query[query.length - 1] === ')') {\n    query = query.slice(1, -1);\n  }\n  // whitespace could be added or removed\n  query = query.replace(/\\s|\\n/g, '');\n  // labels matchers can be reordered, so sort the enitre string, esentially comparing just the character counts\n  return query.split('').sort().join('');\n}\n"],"names":["patchHistoryMethod","method","history","original","state","result","event","useLocationServer","buildState","trigger","_a","length","_b","hash","host","hostname","href","origin","pathname","port","protocol","search","useLocationBrowser","setState","onPopstate","onPushstate","onReplacestate","hasEventConstructor","pageTitle","useRuleFindParams","segments","useLocation","name","sourceName","RedirectToRuleViewer","styles","getStyles","error","loading","rules","dispatched","useCombinedRule","RuleViewerLayout","Alert","LoadingPlaceholder","rulesSource","rule","index","Card","Icon","AlertLabels","theme","defaultPageNav","props","wrapInContent","children","title","getPageStyles","RuleViewerLayoutContent","padding","getContentStyles","identifier","ruleSourceName","requestState","useCombinedRulesLoader","combinedRules","namespace","group","id","useCombinedRulesMatching","ruleName","rulesSourceName","dispatch","promRuleRequests","promRuleRequest","getRequestState","rulerRuleRequests","rulerRuleRequest","slice","useCombinedRuleNamespaces","promRulesResponses","rulerRulesResponses","cache","rulesSources","promRules","rulerRules","cached","namespaces","namespaceName","groups","addRulerGroupsToCombinedNamespace","ns","addPromGroupsToCombinedNamespace","flattenGrafanaManagedRules","newNamespace","sortRulesByName","a","b","combinedGroup","rulerRuleToCombinedRule","existingGroupsByName","combinedRulesByName","r","existingRule","getExistingRuleInGroup","promRuleToCombinedRule","existingCombinedRulesMap","nameMatchingRules","strictlyMatchingRule","combinedRule","isCombinedRuleEqualToPromRule","looselyMatchingRule","checkQuery","hashQuery","query"],"sourceRoot":""}