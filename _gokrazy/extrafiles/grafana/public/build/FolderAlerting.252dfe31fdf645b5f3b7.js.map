{"version":3,"file":"FolderAlerting.252dfe31fdf645b5f3b7.js","mappings":"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","sources":["webpack://grafana/./public/app/features/alerting/unified/hooks/useCombinedRuleNamespaces.ts","webpack://grafana/./public/app/features/alerting/unified/hooks/useURLSearchParams.ts","webpack://grafana/./public/app/features/alerting/unified/AlertsFolderView.tsx","webpack://grafana/./public/app/features/folders/FolderAlerting.tsx"],"sourcesContent":["import { isEqual } from 'lodash';\nimport { useMemo, useRef } from 'react';\n\nimport {\n  CombinedRule,\n  CombinedRuleGroup,\n  CombinedRuleNamespace,\n  Rule,\n  RuleGroup,\n  RuleNamespace,\n  RulesSource,\n} from 'app/types/unified-alerting';\nimport { RulerRuleDTO, RulerRuleGroupDTO, RulerRulesConfigDTO } from 'app/types/unified-alerting-dto';\n\nimport {\n  getAllRulesSources,\n  getRulesSourceByName,\n  isCloudRulesSource,\n  isGrafanaRulesSource,\n} from '../utils/datasource';\nimport { isAlertingRule, isAlertingRulerRule, isRecordingRulerRule } from '../utils/rules';\n\nimport { useUnifiedAlertingSelector } from './useUnifiedAlertingSelector';\n\ninterface CacheValue {\n  promRules?: RuleNamespace[];\n  rulerRules?: RulerRulesConfigDTO | null;\n  result: CombinedRuleNamespace[];\n}\n\n// this little monster combines prometheus rules and ruler rules to produce a unified data structure\n// can limit to a single rules source\nexport function useCombinedRuleNamespaces(rulesSourceName?: string): CombinedRuleNamespace[] {\n  const promRulesResponses = useUnifiedAlertingSelector((state) => state.promRules);\n  const rulerRulesResponses = useUnifiedAlertingSelector((state) => state.rulerRules);\n\n  // cache results per rules source, so we only recalculate those for which results have actually changed\n  const cache = useRef<Record<string, CacheValue>>({});\n\n  const rulesSources = useMemo((): RulesSource[] => {\n    if (rulesSourceName) {\n      const rulesSource = getRulesSourceByName(rulesSourceName);\n      if (!rulesSource) {\n        throw new Error(`Unknown rules source: ${rulesSourceName}`);\n      }\n      return [rulesSource];\n    }\n    return getAllRulesSources();\n  }, [rulesSourceName]);\n\n  return useMemo(\n    () =>\n      rulesSources\n        .map((rulesSource): CombinedRuleNamespace[] => {\n          const rulesSourceName = isCloudRulesSource(rulesSource) ? rulesSource.name : rulesSource;\n          const promRules = promRulesResponses[rulesSourceName]?.result;\n          const rulerRules = rulerRulesResponses[rulesSourceName]?.result;\n\n          const cached = cache.current[rulesSourceName];\n          if (cached && cached.promRules === promRules && cached.rulerRules === rulerRules) {\n            return cached.result;\n          }\n          const namespaces: Record<string, CombinedRuleNamespace> = {};\n\n          // first get all the ruler rules in\n          Object.entries(rulerRules || {}).forEach(([namespaceName, groups]) => {\n            const namespace: CombinedRuleNamespace = {\n              rulesSource,\n              name: namespaceName,\n              groups: [],\n            };\n            namespaces[namespaceName] = namespace;\n            addRulerGroupsToCombinedNamespace(namespace, groups);\n          });\n\n          // then correlate with prometheus rules\n          promRules?.forEach(({ name: namespaceName, groups }) => {\n            const ns = (namespaces[namespaceName] = namespaces[namespaceName] || {\n              rulesSource,\n              name: namespaceName,\n              groups: [],\n            });\n\n            addPromGroupsToCombinedNamespace(ns, groups);\n          });\n\n          const result = Object.values(namespaces);\n\n          cache.current[rulesSourceName] = { promRules, rulerRules, result };\n          return result;\n        })\n        .flat(),\n    [promRulesResponses, rulerRulesResponses, rulesSources]\n  );\n}\n\n// merge all groups in case of grafana managed, essentially treating namespaces (folders) as groups\nexport function flattenGrafanaManagedRules(namespaces: CombinedRuleNamespace[]) {\n  return namespaces.map((namespace) => {\n    const newNamespace: CombinedRuleNamespace = {\n      ...namespace,\n      groups: [],\n    };\n\n    // add default group with ungrouped rules\n    newNamespace.groups.push({\n      name: 'default',\n      rules: sortRulesByName(namespace.groups.flatMap((group) => group.rules)),\n    });\n\n    return newNamespace;\n  });\n}\n\nexport function sortRulesByName(rules: CombinedRule[]) {\n  return rules.sort((a, b) => a.name.localeCompare(b.name));\n}\n\nfunction addRulerGroupsToCombinedNamespace(namespace: CombinedRuleNamespace, groups: RulerRuleGroupDTO[] = []): void {\n  namespace.groups = groups.map((group) => {\n    const combinedGroup: CombinedRuleGroup = {\n      name: group.name,\n      interval: group.interval,\n      source_tenants: group.source_tenants,\n      rules: [],\n    };\n    combinedGroup.rules = group.rules.map((rule) => rulerRuleToCombinedRule(rule, namespace, combinedGroup));\n    return combinedGroup;\n  });\n}\n\nfunction addPromGroupsToCombinedNamespace(namespace: CombinedRuleNamespace, groups: RuleGroup[]): void {\n  const existingGroupsByName = new Map<string, CombinedRuleGroup>();\n  namespace.groups.forEach((group) => existingGroupsByName.set(group.name, group));\n\n  groups.forEach((group) => {\n    let combinedGroup = existingGroupsByName.get(group.name);\n    if (!combinedGroup) {\n      combinedGroup = {\n        name: group.name,\n        rules: [],\n      };\n      namespace.groups.push(combinedGroup);\n      existingGroupsByName.set(group.name, combinedGroup);\n    }\n\n    const combinedRulesByName = new Map<string, CombinedRule[]>();\n    combinedGroup!.rules.forEach((r) => {\n      // Prometheus rules do not have to be unique by name\n      const existingRule = combinedRulesByName.get(r.name);\n      existingRule ? existingRule.push(r) : combinedRulesByName.set(r.name, [r]);\n    });\n\n    (group.rules ?? []).forEach((rule) => {\n      const existingRule = getExistingRuleInGroup(rule, combinedRulesByName, namespace.rulesSource);\n      if (existingRule) {\n        existingRule.promRule = rule;\n      } else {\n        combinedGroup!.rules.push(promRuleToCombinedRule(rule, namespace, combinedGroup!));\n      }\n    });\n  });\n}\n\nfunction promRuleToCombinedRule(rule: Rule, namespace: CombinedRuleNamespace, group: CombinedRuleGroup): CombinedRule {\n  return {\n    name: rule.name,\n    query: rule.query,\n    labels: rule.labels || {},\n    annotations: isAlertingRule(rule) ? rule.annotations || {} : {},\n    promRule: rule,\n    namespace: namespace,\n    group,\n  };\n}\n\nfunction rulerRuleToCombinedRule(\n  rule: RulerRuleDTO,\n  namespace: CombinedRuleNamespace,\n  group: CombinedRuleGroup\n): CombinedRule {\n  return isAlertingRulerRule(rule)\n    ? {\n        name: rule.alert,\n        query: rule.expr,\n        labels: rule.labels || {},\n        annotations: rule.annotations || {},\n        rulerRule: rule,\n        namespace,\n        group,\n      }\n    : isRecordingRulerRule(rule)\n    ? {\n        name: rule.record,\n        query: rule.expr,\n        labels: rule.labels || {},\n        annotations: {},\n        rulerRule: rule,\n        namespace,\n        group,\n      }\n    : {\n        name: rule.grafana_alert.title,\n        query: '',\n        labels: rule.labels || {},\n        annotations: rule.annotations || {},\n        rulerRule: rule,\n        namespace,\n        group,\n      };\n}\n\n// find existing rule in group that matches the given prom rule\nfunction getExistingRuleInGroup(\n  rule: Rule,\n  existingCombinedRulesMap: Map<string, CombinedRule[]>,\n  rulesSource: RulesSource\n): CombinedRule | undefined {\n  // Using Map of name-based rules is important performance optimization for the code below\n  // Otherwise we would perform find method multiple times on (possibly) thousands of rules\n\n  const nameMatchingRules = existingCombinedRulesMap.get(rule.name);\n  if (!nameMatchingRules) {\n    return undefined;\n  }\n\n  if (isGrafanaRulesSource(rulesSource)) {\n    // assume grafana groups have only the one rule. check name anyway because paranoid\n    return nameMatchingRules[0];\n  }\n\n  // try finding a rule that matches name, labels, annotations and query\n  const strictlyMatchingRule = nameMatchingRules.find(\n    (combinedRule) => !combinedRule.promRule && isCombinedRuleEqualToPromRule(combinedRule, rule, true)\n  );\n  if (strictlyMatchingRule) {\n    return strictlyMatchingRule;\n  }\n\n  // if that fails, try finding a rule that only matches name, labels and annotations.\n  // loki & prom can sometimes modify the query so it doesnt match, eg `2 > 1` becomes `1`\n  const looselyMatchingRule = nameMatchingRules.find(\n    (combinedRule) => !combinedRule.promRule && isCombinedRuleEqualToPromRule(combinedRule, rule, false)\n  );\n  if (looselyMatchingRule) {\n    return looselyMatchingRule;\n  }\n\n  return undefined;\n}\n\nfunction isCombinedRuleEqualToPromRule(combinedRule: CombinedRule, rule: Rule, checkQuery = true): boolean {\n  if (combinedRule.name === rule.name) {\n    return isEqual(\n      [checkQuery ? hashQuery(combinedRule.query) : '', combinedRule.labels, combinedRule.annotations],\n      [checkQuery ? hashQuery(rule.query) : '', rule.labels || {}, isAlertingRule(rule) ? rule.annotations || {} : {}]\n    );\n  }\n  return false;\n}\n\n// there can be slight differences in how prom & ruler render a query, this will hash them accounting for the differences\nfunction hashQuery(query: string) {\n  // one of them might be wrapped in parens\n  if (query.length > 1 && query[0] === '(' && query[query.length - 1] === ')') {\n    query = query.slice(1, -1);\n  }\n  // whitespace could be added or removed\n  query = query.replace(/\\s|\\n/g, '');\n  // labels matchers can be reordered, so sort the enitre string, esentially comparing just the character counts\n  return query.split('').sort().join('');\n}\n","import { useCallback, useMemo } from 'react';\nimport { useLocation } from 'react-router-dom';\n\nimport { locationService } from '@grafana/runtime';\n\nexport function useURLSearchParams(): [\n  URLSearchParams,\n  (searchValues: Record<string, string | string[] | undefined>, replace?: boolean) => void\n] {\n  const { search } = useLocation();\n  const queryParams = useMemo(() => new URLSearchParams(search), [search]);\n\n  const update = useCallback((searchValues: Record<string, string | string[] | undefined>, replace?: boolean) => {\n    locationService.partial(searchValues, replace);\n  }, []);\n\n  return [queryParams, update];\n}\n","import { css } from '@emotion/css';\nimport { isEqual, orderBy, uniqWith } from 'lodash';\nimport React, { useEffect, useState } from 'react';\nimport { useDebounce } from 'react-use';\n\nimport { GrafanaTheme2, SelectableValue } from '@grafana/data';\nimport { Stack } from '@grafana/experimental';\nimport { Card, FilterInput, Icon, Pagination, Select, TagList, useStyles2 } from '@grafana/ui';\nimport { DEFAULT_PER_PAGE_PAGINATION } from 'app/core/constants';\nimport { getQueryParamValue } from 'app/core/utils/query';\nimport { FolderState, useDispatch } from 'app/types';\nimport { CombinedRule } from 'app/types/unified-alerting';\n\nimport { useCombinedRuleNamespaces } from './hooks/useCombinedRuleNamespaces';\nimport { usePagination } from './hooks/usePagination';\nimport { useURLSearchParams } from './hooks/useURLSearchParams';\nimport { fetchPromRulesAction, fetchRulerRulesAction } from './state/actions';\nimport { labelsMatchMatchers, matchersToString, parseMatcher, parseMatchers } from './utils/alertmanager';\nimport { GRAFANA_RULES_SOURCE_NAME } from './utils/datasource';\nimport { createViewLink } from './utils/misc';\n\ninterface Props {\n  folder: FolderState;\n}\n\nenum SortOrder {\n  Ascending = 'alpha-asc',\n  Descending = 'alpha-desc',\n}\n\nconst sortOptions: Array<SelectableValue<SortOrder>> = [\n  { label: 'Alphabetically [A-Z]', value: SortOrder.Ascending },\n  { label: 'Alphabetically [Z-A]', value: SortOrder.Descending },\n];\n\nexport const AlertsFolderView = ({ folder }: Props) => {\n  const styles = useStyles2(getStyles);\n  const dispatch = useDispatch();\n\n  const onTagClick = (tagName: string) => {\n    const matchers = parseMatchers(labelFilter);\n    const tagMatcherField = parseMatcher(tagName);\n    const uniqueMatchers = uniqWith([...matchers, tagMatcherField], isEqual);\n    const matchersString = matchersToString(uniqueMatchers);\n    setLabelFilter(matchersString);\n  };\n\n  useEffect(() => {\n    dispatch(fetchPromRulesAction({ rulesSourceName: GRAFANA_RULES_SOURCE_NAME }));\n    dispatch(fetchRulerRulesAction({ rulesSourceName: GRAFANA_RULES_SOURCE_NAME }));\n  }, [dispatch]);\n\n  const combinedNamespaces = useCombinedRuleNamespaces(GRAFANA_RULES_SOURCE_NAME);\n  const { nameFilter, labelFilter, sortOrder, setNameFilter, setLabelFilter, setSortOrder } =\n    useAlertsFolderViewParams();\n\n  const matchingNamespace = combinedNamespaces.find((namespace) => namespace.name === folder.title);\n  const alertRules = matchingNamespace?.groups.flatMap((group) => group.rules) ?? [];\n\n  const filteredRules = filterAndSortRules(alertRules, nameFilter, labelFilter, sortOrder ?? SortOrder.Ascending);\n\n  const hasNoResults = alertRules.length === 0 || filteredRules.length === 0;\n  const { page, numberOfPages, onPageChange, pageItems } = usePagination(filteredRules, 1, DEFAULT_PER_PAGE_PAGINATION);\n\n  return (\n    <div className={styles.container}>\n      <Stack direction=\"column\" gap={3}>\n        <FilterInput\n          value={nameFilter}\n          onChange={setNameFilter}\n          placeholder=\"Search alert rules by name\"\n          data-testid=\"name-filter\"\n        />\n        <Stack direction=\"row\">\n          <Select<SortOrder>\n            value={sortOrder}\n            onChange={({ value }) => value && setSortOrder(value)}\n            options={sortOptions}\n            width={25}\n            aria-label=\"Sort\"\n            placeholder={`Sort (Default A-Z)`}\n            prefix={<Icon name={sortOrder === SortOrder.Ascending ? 'sort-amount-up' : 'sort-amount-down'} />}\n          />\n          <FilterInput\n            value={labelFilter}\n            onChange={setLabelFilter}\n            placeholder=\"Search alerts by labels\"\n            className={styles.filterLabelsInput}\n            data-testid=\"label-filter\"\n          />\n        </Stack>\n\n        <Stack gap={1}>\n          {pageItems.map((currentRule) => (\n            <Card\n              key={currentRule.name}\n              href={createViewLink('grafana', currentRule, '')}\n              className={styles.card}\n              data-testid=\"alert-card-row\"\n            >\n              <Card.Heading>{currentRule.name}</Card.Heading>\n              <Card.Tags>\n                <TagList\n                  onClick={onTagClick}\n                  tags={Object.entries(currentRule.labels).map(([label, value]) => `${label}=${value}`)}\n                />\n              </Card.Tags>\n              <Card.Meta>\n                <div>\n                  <Icon name=\"folder\" /> {folder.title}\n                </div>\n              </Card.Meta>\n            </Card>\n          ))}\n        </Stack>\n        {hasNoResults && <div className={styles.noResults}>No alert rules found</div>}\n        <div className={styles.pagination}>\n          <Pagination\n            currentPage={page}\n            numberOfPages={numberOfPages}\n            onNavigate={onPageChange}\n            hideWhenSinglePage={true}\n          />\n        </div>\n      </Stack>\n    </div>\n  );\n};\n\nenum AlertFolderViewParams {\n  nameFilter = 'nameFilter',\n  labelFilter = 'labelFilter',\n  sortOrder = 'sort',\n}\n\nfunction useAlertsFolderViewParams() {\n  const [searchParams, setSearchParams] = useURLSearchParams();\n\n  const [nameFilter, setNameFilter] = useState(searchParams.get(AlertFolderViewParams.nameFilter) ?? '');\n  const [labelFilter, setLabelFilter] = useState(searchParams.get(AlertFolderViewParams.labelFilter) ?? '');\n\n  const sortParam = searchParams.get(AlertFolderViewParams.sortOrder);\n  const [sortOrder, setSortOrder] = useState<SortOrder | undefined>(\n    sortParam === SortOrder.Ascending\n      ? SortOrder.Ascending\n      : sortParam === SortOrder.Descending\n      ? SortOrder.Descending\n      : undefined\n  );\n\n  useDebounce(\n    () =>\n      setSearchParams(\n        {\n          [AlertFolderViewParams.nameFilter]: getQueryParamValue(nameFilter),\n          [AlertFolderViewParams.labelFilter]: getQueryParamValue(labelFilter),\n          [AlertFolderViewParams.sortOrder]: getQueryParamValue(sortOrder),\n        },\n        true\n      ),\n    400,\n    [nameFilter, labelFilter, sortOrder]\n  );\n\n  return { nameFilter, labelFilter, sortOrder, setNameFilter, setLabelFilter, setSortOrder };\n}\n\nfunction filterAndSortRules(\n  originalRules: CombinedRule[],\n  nameFilter: string,\n  labelFilter: string,\n  sortOrder: SortOrder\n) {\n  const matchers = parseMatchers(labelFilter);\n  let rules = originalRules.filter(\n    (rule) => rule.name.toLowerCase().includes(nameFilter.toLowerCase()) && labelsMatchMatchers(rule.labels, matchers)\n  );\n\n  return orderBy(rules, (x) => x.name.toLowerCase(), [sortOrder === SortOrder.Ascending ? 'asc' : 'desc']);\n}\n\nexport const getStyles = (theme: GrafanaTheme2) => ({\n  container: css`\n    padding: ${theme.spacing(1)};\n  `,\n  card: css`\n    grid-template-columns: auto 1fr 2fr;\n    margin: 0;\n  `,\n  pagination: css`\n    align-self: center;\n  `,\n  filterLabelsInput: css`\n    flex: 1;\n    width: auto;\n    min-width: 240px;\n  `,\n  noResults: css`\n    padding: ${theme.spacing(2)};\n    background-color: ${theme.colors.background.secondary};\n    font-style: italic;\n  `,\n});\n","import React from 'react';\nimport { useAsync } from 'react-use';\n\nimport { Page } from 'app/core/components/Page/Page';\nimport { GrafanaRouteComponentProps } from 'app/core/navigation/types';\nimport { getNavModel } from 'app/core/selectors/navModel';\nimport { useDispatch, useSelector } from 'app/types';\n\nimport { AlertsFolderView } from '../alerting/unified/AlertsFolderView';\n\nimport { getFolderByUid } from './state/actions';\nimport { getLoadingNav } from './state/navModel';\n\nexport interface OwnProps extends GrafanaRouteComponentProps<{ uid: string }> {}\n\nconst FolderAlerting = ({ match }: OwnProps) => {\n  const dispatch = useDispatch();\n  const navIndex = useSelector((state) => state.navIndex);\n  const folder = useSelector((state) => state.folder);\n\n  const uid = match.params.uid;\n  const pageNav = getNavModel(navIndex, `folder-alerting-${uid}`, getLoadingNav(1));\n\n  const { loading } = useAsync(async () => dispatch(getFolderByUid(uid)), [getFolderByUid, uid]);\n\n  return (\n    <Page navId=\"dashboards/browse\" pageNav={pageNav.main}>\n      <Page.Contents isLoading={loading}>\n        <AlertsFolderView folder={folder} />\n      </Page.Contents>\n    </Page>\n  );\n};\n\nexport default FolderAlerting;\n"],"names":["useCombinedRuleNamespaces","rulesSourceName","promRulesResponses","state","rulerRulesResponses","cache","rulesSources","rulesSource","promRules","rulerRules","cached","namespaces","namespaceName","groups","namespace","addRulerGroupsToCombinedNamespace","ns","addPromGroupsToCombinedNamespace","result","flattenGrafanaManagedRules","newNamespace","sortRulesByName","group","rules","a","b","combinedGroup","rule","rulerRuleToCombinedRule","existingGroupsByName","combinedRulesByName","r","existingRule","getExistingRuleInGroup","promRuleToCombinedRule","existingCombinedRulesMap","nameMatchingRules","strictlyMatchingRule","combinedRule","isCombinedRuleEqualToPromRule","looselyMatchingRule","checkQuery","hashQuery","query","useURLSearchParams","search","queryParams","update","searchValues","replace","SortOrder","sortOptions","AlertsFolderView","folder","styles","getStyles","dispatch","onTagClick","tagName","matchers","labelFilter","tagMatcherField","uniqueMatchers","matchersString","setLabelFilter","combinedNamespaces","nameFilter","sortOrder","setNameFilter","setSortOrder","useAlertsFolderViewParams","alertRules","filteredRules","filterAndSortRules","hasNoResults","page","numberOfPages","onPageChange","pageItems","usePagination","FilterInput","Select","value","Icon","currentRule","Card","TagList","label","Pagination","AlertFolderViewParams","searchParams","setSearchParams","sortParam","useDebounce","originalRules","x","theme","match","navIndex","uid","pageNav","loading","useAsync","Page"],"sourceRoot":""}