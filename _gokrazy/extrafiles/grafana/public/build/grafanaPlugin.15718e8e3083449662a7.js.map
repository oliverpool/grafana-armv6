{"version":3,"file":"grafanaPlugin.15718e8e3083449662a7.js","mappings":"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","sources":["webpack://grafana/./public/app/plugins/datasource/grafana/components/AnnotationQueryEditor.tsx","webpack://grafana/./public/app/plugins/datasource/grafana/datasource.ts","webpack://grafana/./public/app/plugins/datasource/grafana/components/QueryEditor.tsx","webpack://grafana/./public/app/plugins/datasource/grafana/module.ts","webpack://grafana/./public/app/plugins/datasource/grafana/types.ts"],"sourcesContent":["import React from 'react';\nimport { SelectableValue } from '@grafana/data';\nimport { Field, FieldSet, Select, Switch } from '@grafana/ui';\nimport { css } from '@emotion/css';\n\nimport { TagFilter } from 'app/core/components/TagFilter/TagFilter';\nimport { GrafanaAnnotationQuery, GrafanaAnnotationType, GrafanaQuery } from '../types';\nimport { getAnnotationTags } from 'app/features/annotations/api';\n\nconst matchTooltipContent = 'Enabling this returns annotations that match any of the tags specified below';\n\nconst tagsTooltipContent = (\n  <div>Specify a list of tags to match. To specify a key and value tag use `key:value` syntax.</div>\n);\n\nconst annotationTypes = [\n  {\n    label: 'Dashboard',\n    value: GrafanaAnnotationType.Dashboard,\n    description: 'Query for events created on this dashboard and show them in the panels where they where created',\n  },\n  {\n    label: 'Tags',\n    value: GrafanaAnnotationType.Tags,\n    description: 'This will fetch any annotation events that match the tags filter',\n  },\n];\n\nconst limitOptions = [10, 50, 100, 200, 300, 500, 1000, 2000].map((limit) => ({\n  label: String(limit),\n  value: limit,\n}));\n\ninterface Props {\n  query: GrafanaQuery;\n  onChange: (newValue: GrafanaAnnotationQuery) => void;\n}\n\nexport default function AnnotationQueryEditor({ query, onChange }: Props) {\n  const annotationQuery = query as GrafanaAnnotationQuery;\n  const { limit, matchAny, tags, type } = annotationQuery;\n  const styles = getStyles();\n\n  const onFilterByChange = (newValue: SelectableValue<GrafanaAnnotationType>) =>\n    onChange({\n      ...annotationQuery,\n      type: newValue.value!,\n    });\n\n  const onMaxLimitChange = (newValue: SelectableValue<number>) =>\n    onChange({\n      ...annotationQuery,\n      limit: newValue.value!,\n    });\n\n  const onMatchAnyChange = (newValue: React.ChangeEvent<HTMLInputElement>) =>\n    onChange({\n      ...annotationQuery,\n      matchAny: newValue.target.checked,\n    });\n\n  const onTagsChange = (tags: string[]) =>\n    onChange({\n      ...annotationQuery,\n      tags,\n    });\n\n  const onFormatCreateLabel = (input: string) => `Use custom value: ${input}`;\n\n  return (\n    <FieldSet className={styles.container}>\n      <Field label=\"Filter by\">\n        <Select\n          menuShouldPortal\n          inputId=\"grafana-annotations__filter-by\"\n          options={annotationTypes}\n          value={type}\n          onChange={onFilterByChange}\n        />\n      </Field>\n      <Field label=\"Max limit\">\n        <Select\n          menuShouldPortal\n          inputId=\"grafana-annotations__limit\"\n          width={16}\n          options={limitOptions}\n          value={limit}\n          onChange={onMaxLimitChange}\n        />\n      </Field>\n      {type === GrafanaAnnotationType.Tags && (\n        <>\n          <Field label=\"Match any\" description={matchTooltipContent}>\n            <Switch id=\"grafana-annotations__match-any\" value={matchAny} onChange={onMatchAnyChange} />\n          </Field>\n          <Field label=\"Tags\" description={tagsTooltipContent}>\n            <TagFilter\n              allowCustomValue\n              formatCreateLabel={onFormatCreateLabel}\n              inputId=\"grafana-annotations__tags\"\n              onChange={onTagsChange}\n              tagOptions={getAnnotationTags}\n              tags={tags ?? []}\n            />\n          </Field>\n        </>\n      )}\n    </FieldSet>\n  );\n}\n\nconst getStyles = () => {\n  return {\n    container: css`\n      max-width: 600px;\n    `,\n  };\n};\n","import { from, merge, Observable, of } from 'rxjs';\nimport {\n  DataSourceWithBackend,\n  getBackendSrv,\n  getGrafanaLiveSrv,\n  getTemplateSrv,\n  StreamingFrameOptions,\n} from '@grafana/runtime';\nimport {\n  AnnotationQuery,\n  AnnotationQueryRequest,\n  DataFrameView,\n  DataQueryRequest,\n  DataQueryResponse,\n  DataSourceInstanceSettings,\n  DataSourceRef,\n  isValidLiveChannelAddress,\n  MutableDataFrame,\n  parseLiveChannelAddress,\n  toDataFrame,\n} from '@grafana/data';\n\nimport { GrafanaAnnotationQuery, GrafanaAnnotationType, GrafanaQuery, GrafanaQueryType } from './types';\nimport AnnotationQueryEditor from './components/AnnotationQueryEditor';\nimport { getDashboardSrv } from '../../../features/dashboard/services/DashboardSrv';\nimport { isString } from 'lodash';\nimport { migrateDatasourceNameToRef } from 'app/features/dashboard/state/DashboardMigrator';\nimport { map } from 'rxjs/operators';\n\nlet counter = 100;\n\nexport class GrafanaDatasource extends DataSourceWithBackend<GrafanaQuery> {\n  constructor(instanceSettings: DataSourceInstanceSettings) {\n    super(instanceSettings);\n    this.annotations = {\n      QueryEditor: AnnotationQueryEditor,\n      prepareAnnotation(json: any): AnnotationQuery<GrafanaAnnotationQuery> {\n        // Previously, these properties lived outside of target\n        // This should handle migrating them\n        json.target = json.target ?? {\n          type: json.type ?? GrafanaAnnotationType.Dashboard,\n          limit: json.limit ?? 100,\n          tags: json.tags ?? [],\n          matchAny: json.matchAny ?? false,\n        }; // using spread syntax caused an infinite loop in StandardAnnotationQueryEditor\n        return json;\n      },\n      prepareQuery(anno: AnnotationQuery<GrafanaAnnotationQuery>): GrafanaQuery {\n        let datasource: DataSourceRef | undefined | null = undefined;\n        if (isString(anno.datasource)) {\n          const ref = migrateDatasourceNameToRef(anno.datasource, { returnDefaultAsNull: false });\n          if (ref) {\n            datasource = ref;\n          }\n        } else {\n          datasource = anno.datasource as DataSourceRef;\n        }\n\n        return { ...anno, refId: anno.name, queryType: GrafanaQueryType.Annotations, datasource };\n      },\n    };\n  }\n\n  query(request: DataQueryRequest<GrafanaQuery>): Observable<DataQueryResponse> {\n    const results: Array<Observable<DataQueryResponse>> = [];\n    const targets: GrafanaQuery[] = [];\n    const templateSrv = getTemplateSrv();\n    for (const target of request.targets) {\n      if (target.queryType === GrafanaQueryType.Annotations) {\n        return from(\n          this.getAnnotations({\n            range: request.range,\n            rangeRaw: request.range.raw,\n            annotation: target as unknown as AnnotationQuery<GrafanaAnnotationQuery>,\n            dashboard: getDashboardSrv().getCurrent(),\n          })\n        );\n      }\n      if (target.hide) {\n        continue;\n      }\n      if (target.queryType === GrafanaQueryType.LiveMeasurements) {\n        let channel = templateSrv.replace(target.channel, request.scopedVars);\n        const { filter } = target;\n\n        // Help migrate pre-release channel paths saved in dashboards\n        // NOTE: this should be removed before V8 is released\n        if (channel && channel.startsWith('telegraf/')) {\n          channel = 'stream/' + channel;\n          target.channel = channel; // mutate the current query object so it is saved with `stream/` prefix\n        }\n\n        const addr = parseLiveChannelAddress(channel);\n        if (!isValidLiveChannelAddress(addr)) {\n          continue;\n        }\n        const buffer: Partial<StreamingFrameOptions> = {\n          maxLength: request.maxDataPoints ?? 500,\n        };\n        if (target.buffer) {\n          buffer.maxDelta = target.buffer;\n          buffer.maxLength = buffer.maxLength! * 2; //??\n        } else if (request.rangeRaw?.to === 'now') {\n          buffer.maxDelta = request.range.to.valueOf() - request.range.from.valueOf();\n        }\n\n        results.push(\n          getGrafanaLiveSrv().getDataStream({\n            key: `${request.requestId}.${counter++}`,\n            addr: addr!,\n            filter,\n            buffer,\n          })\n        );\n      } else {\n        if (!target.queryType) {\n          target.queryType = GrafanaQueryType.RandomWalk;\n        }\n        targets.push(target);\n      }\n    }\n\n    if (targets.length) {\n      results.push(\n        super.query({\n          ...request,\n          targets,\n        })\n      );\n    }\n\n    if (results.length) {\n      // With a single query just return the results\n      if (results.length === 1) {\n        return results[0];\n      }\n      return merge(...results);\n    }\n    return of(); // nothing\n  }\n\n  listFiles(path: string): Observable<DataFrameView<FileElement>> {\n    return this.query({\n      targets: [\n        {\n          refId: 'A',\n          queryType: GrafanaQueryType.List,\n          path,\n        },\n      ],\n    } as any).pipe(\n      map((v) => {\n        const frame = v.data[0] ?? new MutableDataFrame();\n        return new DataFrameView<FileElement>(frame);\n      })\n    );\n  }\n\n  metricFindQuery(options: any) {\n    return Promise.resolve([]);\n  }\n\n  async getAnnotations(options: AnnotationQueryRequest<GrafanaQuery>): Promise<DataQueryResponse> {\n    const templateSrv = getTemplateSrv();\n    const annotation = options.annotation as unknown as AnnotationQuery<GrafanaAnnotationQuery>;\n    const target = annotation.target!;\n    const params: any = {\n      from: options.range.from.valueOf(),\n      to: options.range.to.valueOf(),\n      limit: target.limit,\n      tags: target.tags,\n      matchAny: target.matchAny,\n    };\n\n    if (target.type === GrafanaAnnotationType.Dashboard) {\n      // if no dashboard id yet return\n      if (!options.dashboard.id) {\n        return Promise.resolve({ data: [] });\n      }\n      // filter by dashboard id\n      params.dashboardId = options.dashboard.id;\n      // remove tags filter if any\n      delete params.tags;\n    } else {\n      // require at least one tag\n      if (!Array.isArray(target.tags) || target.tags.length === 0) {\n        return Promise.resolve({ data: [] });\n      }\n      const delimiter = '__delimiter__';\n      const tags = [];\n      for (const t of params.tags) {\n        const renderedValues = templateSrv.replace(t, {}, (value: any) => {\n          if (typeof value === 'string') {\n            return value;\n          }\n\n          return value.join(delimiter);\n        });\n        for (const tt of renderedValues.split(delimiter)) {\n          tags.push(tt);\n        }\n      }\n      params.tags = tags;\n    }\n\n    const annotations = await getBackendSrv().get(\n      '/api/annotations',\n      params,\n      `grafana-data-source-annotations-${annotation.name}-${options.dashboard?.id}`\n    );\n    return { data: [toDataFrame(annotations)] };\n  }\n\n  testDatasource() {\n    return Promise.resolve();\n  }\n}\n\nexport interface FileElement {\n  name: string;\n  ['media-type']: string;\n}\n","import React, { PureComponent } from 'react';\nimport { InlineField, Select, Alert, Input, InlineFieldRow } from '@grafana/ui';\nimport {\n  QueryEditorProps,\n  SelectableValue,\n  dataFrameFromJSON,\n  rangeUtil,\n  DataQueryRequest,\n  DataFrame,\n} from '@grafana/data';\nimport { GrafanaDatasource } from '../datasource';\nimport { defaultQuery, GrafanaQuery, GrafanaQueryType } from '../types';\nimport { config, getBackendSrv, getDataSourceSrv } from '@grafana/runtime';\n\ntype Props = QueryEditorProps<GrafanaDatasource, GrafanaQuery>;\n\nconst labelWidth = 12;\n\ninterface State {\n  channels: Array<SelectableValue<string>>;\n  channelFields: Record<string, Array<SelectableValue<string>>>;\n  folders?: Array<SelectableValue<string>>;\n}\n\nexport class QueryEditor extends PureComponent<Props, State> {\n  state: State = { channels: [], channelFields: {} };\n\n  queryTypes: Array<SelectableValue<GrafanaQueryType>> = [\n    {\n      label: 'Random Walk',\n      value: GrafanaQueryType.RandomWalk,\n      description: 'Random signal within the selected time range',\n    },\n    {\n      label: 'Live Measurements',\n      value: GrafanaQueryType.LiveMeasurements,\n      description: 'Stream real-time measurements from Grafana',\n    },\n    {\n      label: 'List public files',\n      value: GrafanaQueryType.List,\n      description: 'Show directory listings for public resources',\n    },\n  ];\n\n  constructor(props: Props) {\n    super(props);\n\n    if (config.featureToggles.panelTitleSearch) {\n      this.queryTypes.push({\n        label: 'Search',\n        value: GrafanaQueryType.Search,\n        description: 'Search for grafana resources',\n      });\n    }\n  }\n\n  loadChannelInfo() {\n    getBackendSrv()\n      .fetch({ url: 'api/live/list' })\n      .subscribe({\n        next: (v: any) => {\n          const channelInfo = v.data?.channels as any[];\n          if (channelInfo?.length) {\n            const channelFields: Record<string, Array<SelectableValue<string>>> = {};\n            const channels: Array<SelectableValue<string>> = channelInfo.map((c) => {\n              if (c.data) {\n                const distinctFields = new Set<string>();\n                const frame = dataFrameFromJSON(c.data);\n                for (const f of frame.fields) {\n                  distinctFields.add(f.name);\n                }\n                channelFields[c.channel] = Array.from(distinctFields).map((n) => ({\n                  value: n,\n                  label: n,\n                }));\n              }\n              return {\n                value: c.channel,\n                label: c.channel + ' [' + c.minute_rate + ' msg/min]',\n              };\n            });\n\n            this.setState({ channelFields, channels });\n          }\n        },\n      });\n  }\n\n  loadFolderInfo() {\n    const query: DataQueryRequest<GrafanaQuery> = {\n      targets: [{ queryType: GrafanaQueryType.List, refId: 'A' }],\n    } as any;\n\n    getDataSourceSrv()\n      .get('-- Grafana --')\n      .then((ds) => {\n        const gds = ds as GrafanaDatasource;\n        gds.query(query).subscribe({\n          next: (rsp) => {\n            if (rsp.data.length) {\n              const names = (rsp.data[0] as DataFrame).fields[0];\n              const folders = names.values.toArray().map((v) => ({\n                value: v,\n                label: v,\n              }));\n              this.setState({ folders });\n            }\n          },\n        });\n      });\n  }\n\n  componentDidMount() {\n    this.loadChannelInfo();\n  }\n\n  onQueryTypeChange = (sel: SelectableValue<GrafanaQueryType>) => {\n    const { onChange, query, onRunQuery } = this.props;\n    onChange({ ...query, queryType: sel.value! });\n    onRunQuery();\n\n    // Reload the channel list\n    this.loadChannelInfo();\n  };\n\n  onChannelChange = (sel: SelectableValue<string>) => {\n    const { onChange, query, onRunQuery } = this.props;\n    onChange({ ...query, channel: sel?.value });\n    onRunQuery();\n  };\n\n  onFieldNamesChange = (item: SelectableValue<string>) => {\n    const { onChange, query, onRunQuery } = this.props;\n    let fields: string[] = [];\n    if (Array.isArray(item)) {\n      fields = item.map((v) => v.value);\n    } else if (item.value) {\n      fields = [item.value];\n    }\n\n    // When adding the first field, also add time (if it exists)\n    if (fields.length === 1 && !query.filter?.fields?.length && query.channel) {\n      const names = this.state.channelFields[query.channel] ?? [];\n      const tf = names.find((f) => f.value === 'time' || f.value === 'Time');\n      if (tf && tf.value && tf.value !== fields[0]) {\n        fields = [tf.value, ...fields];\n      }\n    }\n\n    onChange({\n      ...query,\n      filter: {\n        ...query.filter,\n        fields,\n      },\n    });\n    onRunQuery();\n  };\n\n  checkAndUpdateValue = (key: keyof GrafanaQuery, txt: string) => {\n    const { onChange, query, onRunQuery } = this.props;\n    if (key === 'buffer') {\n      let buffer: number | undefined;\n      if (txt) {\n        try {\n          buffer = rangeUtil.intervalToSeconds(txt) * 1000;\n        } catch (err) {\n          console.warn('ERROR', err);\n        }\n      }\n      onChange({\n        ...query,\n        buffer,\n      });\n    } else {\n      onChange({\n        ...query,\n        [key]: txt,\n      });\n    }\n    onRunQuery();\n  };\n\n  handleEnterKey = (e: React.KeyboardEvent<HTMLInputElement>) => {\n    if (e.key !== 'Enter') {\n      return;\n    }\n    this.checkAndUpdateValue('buffer', (e.target as any).value);\n  };\n\n  handleBlur = (e: React.FocusEvent<HTMLInputElement>) => {\n    this.checkAndUpdateValue('buffer', e.target.value);\n  };\n\n  renderMeasurementsQuery() {\n    let { channel, filter, buffer } = this.props.query;\n    let { channels, channelFields } = this.state;\n    let currentChannel = channels.find((c) => c.value === channel);\n    if (channel && !currentChannel) {\n      currentChannel = {\n        value: channel,\n        label: channel,\n        description: `Connected to ${channel}`,\n      };\n      channels = [currentChannel, ...channels];\n    }\n\n    const distinctFields = new Set<string>();\n    const fields: Array<SelectableValue<string>> = channel ? channelFields[channel] ?? [] : [];\n    // if (data && data.series?.length) {\n    //   for (const frame of data.series) {\n    //     for (const field of frame.fields) {\n    //       if (distinctFields.has(field.name) || !field.name) {\n    //         continue;\n    //       }\n    //       fields.push({\n    //         value: field.name,\n    //         label: field.name,\n    //         description: `(${getFrameDisplayName(frame)} / ${field.type})`,\n    //       });\n    //       distinctFields.add(field.name);\n    //     }\n    //   }\n    // }\n    if (filter?.fields) {\n      for (const f of filter.fields) {\n        if (!distinctFields.has(f)) {\n          fields.push({\n            value: f,\n            label: `${f} (not loaded)`,\n            description: `Configured, but not found in the query results`,\n          });\n          distinctFields.add(f);\n        }\n      }\n    }\n\n    let formattedTime = '';\n    if (buffer) {\n      formattedTime = rangeUtil.secondsToHms(buffer / 1000);\n    }\n\n    return (\n      <>\n        <div className=\"gf-form\">\n          <InlineField label=\"Channel\" grow={true} labelWidth={labelWidth}>\n            <Select\n              menuShouldPortal\n              options={channels}\n              value={currentChannel || ''}\n              onChange={this.onChannelChange}\n              allowCustomValue={true}\n              backspaceRemovesValue={true}\n              placeholder=\"Select measurements channel\"\n              isClearable={true}\n              noOptionsMessage=\"Enter channel name\"\n              formatCreateLabel={(input: string) => `Connect to: ${input}`}\n            />\n          </InlineField>\n        </div>\n        {channel && (\n          <div className=\"gf-form\">\n            <InlineField label=\"Fields\" grow={true} labelWidth={labelWidth}>\n              <Select\n                menuShouldPortal\n                options={fields}\n                value={filter?.fields || []}\n                onChange={this.onFieldNamesChange}\n                allowCustomValue={true}\n                backspaceRemovesValue={true}\n                placeholder=\"All fields\"\n                isClearable={true}\n                noOptionsMessage=\"Unable to list all fields\"\n                formatCreateLabel={(input: string) => `Field: ${input}`}\n                isSearchable={true}\n                isMulti={true}\n              />\n            </InlineField>\n            <InlineField label=\"Buffer\">\n              <Input\n                placeholder=\"Auto\"\n                width={12}\n                defaultValue={formattedTime}\n                onKeyDown={this.handleEnterKey}\n                onBlur={this.handleBlur}\n                spellCheck={false}\n              />\n            </InlineField>\n          </div>\n        )}\n\n        <Alert title=\"Grafana Live - Measurements\" severity=\"info\">\n          This supports real-time event streams in Grafana core. This feature is under heavy development. Expect the\n          interfaces and structures to change as this becomes more production ready.\n        </Alert>\n      </>\n    );\n  }\n\n  onFolderChanged = (sel: SelectableValue<string>) => {\n    const { onChange, query, onRunQuery } = this.props;\n    onChange({ ...query, path: sel?.value });\n    onRunQuery();\n  };\n\n  renderListPublicFiles() {\n    let { path } = this.props.query;\n    let { folders } = this.state;\n    if (!folders) {\n      folders = [];\n      this.loadFolderInfo();\n    }\n    const currentFolder = folders.find((f) => f.value === path);\n    if (path && !currentFolder) {\n      folders = [\n        ...folders,\n        {\n          value: path,\n          label: path,\n        },\n      ];\n    }\n\n    return (\n      <InlineFieldRow>\n        <InlineField label=\"Path\" grow={true} labelWidth={labelWidth}>\n          <Select\n            menuShouldPortal\n            options={folders}\n            value={currentFolder || ''}\n            onChange={this.onFolderChanged}\n            allowCustomValue={true}\n            backspaceRemovesValue={true}\n            placeholder=\"Select folder\"\n            isClearable={true}\n            formatCreateLabel={(input: string) => `Folder: ${input}`}\n          />\n        </InlineField>\n      </InlineFieldRow>\n    );\n  }\n\n  handleSearchEnterKey = (e: React.KeyboardEvent<HTMLInputElement>) => {\n    if (e.key !== 'Enter') {\n      return;\n    }\n    this.checkAndUpdateValue('query', (e.target as any).value);\n  };\n\n  handleSearchBlur = (e: React.FocusEvent<HTMLInputElement>) => {\n    this.checkAndUpdateValue('query', e.target.value);\n  };\n\n  renderSearch() {\n    let { query } = this.props.query;\n    return (\n      <InlineFieldRow>\n        <InlineField label=\"Query\" grow={true} labelWidth={labelWidth}>\n          <Input\n            placeholder=\"Everything\"\n            defaultValue={query ?? ''}\n            onKeyDown={this.handleSearchEnterKey}\n            onBlur={this.handleSearchBlur}\n            spellCheck={false}\n          />\n        </InlineField>\n      </InlineFieldRow>\n    );\n  }\n\n  render() {\n    const query = {\n      ...defaultQuery,\n      ...this.props.query,\n    };\n\n    return (\n      <>\n        <InlineFieldRow>\n          <InlineField label=\"Query type\" grow={true} labelWidth={labelWidth}>\n            <Select\n              menuShouldPortal\n              options={this.queryTypes}\n              value={this.queryTypes.find((v) => v.value === query.queryType) || this.queryTypes[0]}\n              onChange={this.onQueryTypeChange}\n            />\n          </InlineField>\n        </InlineFieldRow>\n        {query.queryType === GrafanaQueryType.LiveMeasurements && this.renderMeasurementsQuery()}\n        {query.queryType === GrafanaQueryType.List && this.renderListPublicFiles()}\n        {query.queryType === GrafanaQueryType.Search && this.renderSearch()}\n      </>\n    );\n  }\n}\n","import { DataSourcePlugin } from '@grafana/data';\nimport { GrafanaDatasource } from './datasource';\nimport { QueryEditor } from './components/QueryEditor';\nimport { GrafanaQuery } from './types';\n\nexport const plugin = new DataSourcePlugin<GrafanaDatasource, GrafanaQuery>(GrafanaDatasource).setQueryEditor(\n  QueryEditor\n);\n","import { DataQuery } from '@grafana/data';\nimport { LiveDataFilter } from '@grafana/runtime';\n\n//----------------------------------------------\n// Query\n//----------------------------------------------\n\nexport enum GrafanaQueryType {\n  LiveMeasurements = 'measurements',\n  Annotations = 'annotations',\n\n  // backend\n  RandomWalk = 'randomWalk',\n  List = 'list',\n  Read = 'read',\n  Search = 'search',\n}\n\nexport interface GrafanaQuery extends DataQuery {\n  queryType: GrafanaQueryType; // RandomWalk by default\n  channel?: string;\n  filter?: LiveDataFilter;\n  buffer?: number;\n  path?: string; // for list and read\n  query?: string; // for query endpoint\n}\n\nexport const defaultQuery: GrafanaQuery = {\n  refId: 'A',\n  queryType: GrafanaQueryType.RandomWalk,\n};\n\n//----------------------------------------------\n// Annotations\n//----------------------------------------------\n\nexport enum GrafanaAnnotationType {\n  Dashboard = 'dashboard',\n  Tags = 'tags',\n}\n\nexport interface GrafanaAnnotationQuery extends GrafanaQuery {\n  type: GrafanaAnnotationType; // tags\n  limit: number; // 100\n  tags?: string[];\n  matchAny?: boolean; // By default Grafana only shows annotations that match all tags in the query. Enabling this returns annotations that match any of the tags in the query.\n}\n"],"names":["tagsTooltipContent","annotationTypes","label","value","GrafanaAnnotationType","description","limitOptions","map","limit","String","AnnotationQueryEditor","query","onChange","annotationQuery","matchAny","tags","type","styles","getStyles","FieldSet","className","container","Field","Select","menuShouldPortal","inputId","options","newValue","width","Switch","id","target","checked","TagFilter","allowCustomValue","formatCreateLabel","input","tagOptions","getAnnotationTags","css","counter","GrafanaDatasource","DataSourceWithBackend","constructor","instanceSettings","super","this","annotations","QueryEditor","prepareAnnotation","json","prepareQuery","anno","datasource","isString","ref","migrateDatasourceNameToRef","returnDefaultAsNull","refId","name","queryType","GrafanaQueryType","request","results","targets","templateSrv","getTemplateSrv","from","getAnnotations","range","rangeRaw","raw","annotation","dashboard","getDashboardSrv","getCurrent","hide","channel","replace","scopedVars","filter","startsWith","addr","parseLiveChannelAddress","isValidLiveChannelAddress","buffer","maxLength","maxDataPoints","maxDelta","to","valueOf","push","getGrafanaLiveSrv","getDataStream","key","requestId","length","merge","of","listFiles","path","pipe","v","frame","data","MutableDataFrame","DataFrameView","metricFindQuery","Promise","resolve","params","dashboardId","Array","isArray","delimiter","t","renderedValues","join","tt","split","getBackendSrv","get","toDataFrame","testDatasource","PureComponent","props","channels","channelFields","sel","onRunQuery","loadChannelInfo","item","fields","tf","state","find","f","txt","rangeUtil","err","console","warn","e","checkAndUpdateValue","config","queryTypes","fetch","url","subscribe","next","channelInfo","c","distinctFields","Set","dataFrameFromJSON","add","n","minute_rate","setState","loadFolderInfo","getDataSourceSrv","then","ds","rsp","folders","values","toArray","componentDidMount","renderMeasurementsQuery","currentChannel","has","formattedTime","InlineField","grow","labelWidth","onChannelChange","backspaceRemovesValue","placeholder","isClearable","noOptionsMessage","onFieldNamesChange","isSearchable","isMulti","Input","defaultValue","onKeyDown","handleEnterKey","onBlur","handleBlur","spellCheck","Alert","title","severity","renderListPublicFiles","currentFolder","InlineFieldRow","onFolderChanged","renderSearch","handleSearchEnterKey","handleSearchBlur","render","defaultQuery","onQueryTypeChange","plugin","DataSourcePlugin","setQueryEditor","RandomWalk"],"sourceRoot":""}